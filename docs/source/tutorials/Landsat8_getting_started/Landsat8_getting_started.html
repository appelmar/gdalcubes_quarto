<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="author" content="Marius Appel">
<title>gdalcubes - Introduction to gdalcubes using local Landsat 8 imagery</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>

<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../favicon.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light"><script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script><link rel="stylesheet" href="../../../styles.css">
</head>
<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="navbar navbar-expand-lg navbar-dark "><div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../source/gdalcubes_logo_mini.png" alt="" class="navbar-logo"></a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">gdalcubes</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
<li class="nav-item">
    <a class="nav-link" href="../../../source/getstarted.html" rel="" target="">
 <span class="menu-text">Get started</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../source/introduction/why.html" rel="" target="">
 <span class="menu-text">Overview</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../../source/tutorials/index.html" rel="" target="" aria-current="page">
 <span class="menu-text">Tutorials</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../source/reference/index.html" rel="" target="">
 <span class="menu-text">Reference</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-help" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Help</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-help">
<li>
    <a class="dropdown-item" href="https://github.com/appelmar/gdalcubes_R" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="dropdown-text">Source code</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/appelmar/gdalcubes_R/issues" rel="" target=""><i class="bi bi-bug" role="img">
</i> 
 <span class="dropdown-text">Report an issue</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../source/introduction/faq.html" rel="" target=""><i class="bi bi-question-circle" role="img">
</i> 
 <span class="dropdown-text">FAQ</span></a>
  </li>  
    </ul>
</li>
  <li class="nav-item">
    <a class="nav-link" href="../../../source/about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
</ul>
<ul class="navbar-nav navbar-nav-scroll ms-auto">
<li class="nav-item compact">
    <a class="nav-link" href="https://github.com/appelmar/gdalcubes_R" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
<div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../source/tutorials/vignettes/gc01_MODIS.html">Get started</a></li><li class="breadcrumb-item"><a href="../../../source/tutorials/Landsat8_getting_started/Landsat8_getting_started.html">2. In-depth: Analyzing Landsat image collections</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
    </div>
  </nav></header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto"><div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/tutorials/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tutorials</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Get started</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/tutorials/vignettes/gc01_MODIS.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. Quickstart: Creating data cubes from local MODIS imagery</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/tutorials/Landsat8_getting_started/Landsat8_getting_started.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">2. In-depth: Analyzing Landsat image collections</span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="false">
 <span class="menu-text">User-defined functions</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/tutorials/bfast/bfast.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. Change detection with bfast</span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false">
 <span class="menu-text">Cloud data access</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/tutorials/vignettes/gc02_AWS_Sentinel2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. Sentinel-2 data on AWS</span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false">
 <span class="menu-text">Extraction from data cubes</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 ">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/tutorials/vignettes/gc03_ML_training_data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. Extract training data for ML models</span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../source/tutorials/videos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Videos</span></a>
  </div>
</li>
    </ul>
</div>
</nav><div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active"><h2 id="toc-title">On this page</h2>
   
  <ul>
<li><a href="#outline" id="toc-outline" class="nav-link active" data-scroll-target="#outline">Outline</a></li>
  <li><a href="#sample-data" id="toc-sample-data" class="nav-link" data-scroll-target="#sample-data">Sample Data</a></li>
  <li>
<a href="#part-i-creating-visualizing-and-exporting-data-cubes-from-satellite-image-collections" id="toc-part-i-creating-visualizing-and-exporting-data-cubes-from-satellite-image-collections" class="nav-link" data-scroll-target="#part-i-creating-visualizing-and-exporting-data-cubes-from-satellite-image-collections">Part I: Creating, Visualizing, and Exporting Data Cubes from Satellite Image Collections</a>
  <ul class="collapse">
<li><a href="#the-problem" id="toc-the-problem" class="nav-link" data-scroll-target="#the-problem">The Problem</a></li>
  <li><a href="#existing-tools-with-a-focus-on-r" id="toc-existing-tools-with-a-focus-on-r" class="nav-link" data-scroll-target="#existing-tools-with-a-focus-on-r">Existing Tools (with a focus on R)</a></li>
  <li><a href="#first-steps-with-gdalcubes" id="toc-first-steps-with-gdalcubes" class="nav-link" data-scroll-target="#first-steps-with-gdalcubes">First Steps with gdalcubes</a></li>
  <li><a href="#creating-an-image-collection" id="toc-creating-an-image-collection" class="nav-link" data-scroll-target="#creating-an-image-collection">Creating an Image Collection</a></li>
  <li><a href="#defining-a-data-cube-view-a-virtual-data-cube" id="toc-defining-a-data-cube-view-a-virtual-data-cube" class="nav-link" data-scroll-target="#defining-a-data-cube-view-a-virtual-data-cube">Defining a <em>Data Cube View</em>: A Virtual Data Cube</a></li>
  <li><a href="#creating-data-cubes" id="toc-creating-data-cubes" class="nav-link" data-scroll-target="#creating-data-cubes">Creating Data Cubes</a></li>
  <li>
<a href="#plotting-data-cubes" id="toc-plotting-data-cubes" class="nav-link" data-scroll-target="#plotting-data-cubes">Plotting Data Cubes</a>
  <ul class="collapse">
<li><a href="#animations" id="toc-animations" class="nav-link" data-scroll-target="#animations">Animations</a></li>
  </ul>
</li>
  <li><a href="#exporting-data-cubes-to-disk" id="toc-exporting-data-cubes-to-disk" class="nav-link" data-scroll-target="#exporting-data-cubes-to-disk">Exporting Data Cubes to Disk</a></li>
  <li><a href="#interfacing-existing-r-packages" id="toc-interfacing-existing-r-packages" class="nav-link" data-scroll-target="#interfacing-existing-r-packages">Interfacing Existing R Packages</a></li>
  <li><a href="#more-data-cube-creation-options" id="toc-more-data-cube-creation-options" class="nav-link" data-scroll-target="#more-data-cube-creation-options">More Data Cube Creation Options</a></li>
  </ul>
</li>
  <li><a href="#exercises-i" id="toc-exercises-i" class="nav-link" data-scroll-target="#exercises-i">Exercises (i)</a></li>
  <li>
<a href="#part-ii-on-the-fly-processing-of-data-cubes" id="toc-part-ii-on-the-fly-processing-of-data-cubes" class="nav-link" data-scroll-target="#part-ii-on-the-fly-processing-of-data-cubes">Part II: On-the-fly Processing of Data Cubes</a>
  <ul class="collapse">
<li><a href="#arithmetic-expressions-on-data-cube-bands" id="toc-arithmetic-expressions-on-data-cube-bands" class="nav-link" data-scroll-target="#arithmetic-expressions-on-data-cube-bands">Arithmetic Expressions on Data Cube Bands</a></li>
  <li><a href="#reduction-over-time-and-space" id="toc-reduction-over-time-and-space" class="nav-link" data-scroll-target="#reduction-over-time-and-space">Reduction Over Time and Space</a></li>
  <li><a href="#time-series-methods" id="toc-time-series-methods" class="nav-link" data-scroll-target="#time-series-methods">Time-series methods</a></li>
  <li><a href="#user-defined-functions" id="toc-user-defined-functions" class="nav-link" data-scroll-target="#user-defined-functions">User-defined Functions</a></li>
  <li><a href="#for-developers-process-graphs" id="toc-for-developers-process-graphs" class="nav-link" data-scroll-target="#for-developers-process-graphs">For Developers: Process Graphs</a></li>
  </ul>
</li>
  <li><a href="#summary-limitations-and-future-work" id="toc-summary-limitations-and-future-work" class="nav-link" data-scroll-target="#summary-limitations-and-future-work">Summary, Limitations, and Future Work</a></li>
  <li><a href="#exercises-ii" id="toc-exercises-ii" class="nav-link" data-scroll-target="#exercises-ii">Exercises (ii)</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block default"><div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Introduction to gdalcubes using local Landsat 8 imagery</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Marius Appel </p>
          </div>
  </div>
    
  
    
  </div>
  

</header><p><em>This document is based on the tutorial “Processing Large Satellite Image Collections as Data Cubes with the gdalcubes R package”, presented ad OpenGeoHub Summer School 2019 (see https://github.com/appelmar/opengeohub_summerschool2019).</em></p>
<section id="outline" class="level1"><h1>Outline</h1>
<ul>
<li><p>Part I: Creating, Visualizing, and Exporting Data Cubes from Satellite Image Collections (45 min demonstration, 15 min practical exercises)</p></li>
<li><p>Part II: On-the-fly Processing of Data Cubes (45 min demonstration, 15 min practical exercises)</p></li>
</ul>
<p>All the material of this tutorial is online at <a href="https://github.com/appelmar/opengeohub_summerschool2019">GitHub</a>, including R markdown sources, rendered HTML output, and solutions to the practical exercises. However, the repository does <strong>not</strong> contain the data used in the tutorial due to its size.</p>
<hr></section><section id="sample-data" class="level1"><h1>Sample Data</h1>
<p>Most parts of the tutorial will use a collection of 180 Landsat 8 surface reflectance images, covering a small part of the Brazilian Amazon forest. The live demonstration will use the full resolution dataset (62 gigabytes compressed; &gt; 200 gigabytes unzipped; available <a href="https://hs-bochum.sciebo.de/s/OAcZqaLA28VyrH8/download">here</a>), whereas we will use a downsampled version of the same dataset with coarse spatial resolution (300 meter pixel size; 740 megabytes compressed; 2 gigabytes unzipped) in the practical part (available <a href="https://hs-bochum.sciebo.de/s/8XcKAmPfPGp2CYh/download">here</a>).</p>
<p>After downloading whichever version of the dataset, make sure to unzip it. The following R code will download the low resolution version to your current working directory and unzip it.</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/download_fdf836e13e55be2cd23e76734b3b851c">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="fu">download.file</span>(<span class="st">"https://hs-bochum.sciebo.de/s/8XcKAmPfPGp2CYh/download"</span>, </span>
<span id="cb1-2"><a href="#cb1-2"></a>              <span class="at">destfile =</span> <span class="st">"L8_Amazon.zip"</span>, <span class="at">mode=</span><span class="st">"wb"</span>)</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="fu">unzip</span>(<span class="st">"L8_Amazon.zip"</span>, <span class="at">exdir =</span> <span class="st">"L8_Amazon"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr></section><section id="part-i-creating-visualizing-and-exporting-data-cubes-from-satellite-image-collections" class="level1"><h1>Part I: Creating, Visualizing, and Exporting Data Cubes from Satellite Image Collections</h1>
<section id="the-problem" class="level2"><h2 class="anchored" data-anchor-id="the-problem">The Problem</h2>
<p>Raw satellite imagery is mostly distributed as collection of files, whether on download portals of space agencies, or in cloud computing environments (Amazon Web Services, Google Cloud, …). If we want to analyze more than a single image, or even images from multiple satellites, we quickly run into the following challenges:</p>
<ul>
<li>spectral bands at different spatial resolutions</li>
<li>spatially overlapping images</li>
<li>irregular time series for pixels from different tiles (or in overlapping areas)</li>
<li>different spatial reference systems of images</li>
<li>different data formats and structures</li>
</ul>
<p>To do time series analysis, process larger areas, and / or combine datasets from different sensors / satellites, we first must restructure our data, e.g.&nbsp;as a data cube with a single spatial reference system, regular pixel sizes, both in time and in space.</p>
<p><img src="cube.png" class="img-fluid"></p>
<p>Notice that what we call <em>cube</em> is actually not really a cube. It has (up to) four dimensions, and the lengths of the dimensions may be different. Therefore, four dimensional regular raster data cubes also cover simple time series, multiband time series, grayscale images, multispectral images, and time-series of images.</p>
</section><section id="existing-tools-with-a-focus-on-r" class="level2"><h2 class="anchored" data-anchor-id="existing-tools-with-a-focus-on-r">Existing Tools (with a focus on R)</h2>
<p><a href="https://gdal.org">GDAL</a>, the Geospatial Data Abstraction Library is a software library reading and writing all relevant raster (and vector) data formats, and providing functions to warp (reproject, rescale, resample, and crop) multiband raster images. It has a three dimensional (space, bands) raster data model and solves some of the problems (data formats, image warping). However, it does <em>not</em> know about the organization of data products, and time. GDAL is written in C / C++ but the <code>rgdal</code>package <span class="citation" data-cites="rgdal">(<a href="#ref-rgdal" role="doc-biblioref">Bivand, Keitt, and Rowlingson 2019</a>)</span> provides an easy to use interface in R.</p>
<p>There are further R packages to process satellite imagery:</p>
<p><code>raster</code> <span class="citation" data-cites="raster">(<a href="#ref-raster" role="doc-biblioref">Hijmans 2019</a>)</span></p>
<ul>
<li>well established, stable, reliable</li>
<li>three-dimensional only, no multispectral AND multitemporal stacks</li>
<li>chaining operations on rasters (stacks / bricks) always writes intermediate results to disk</li>
<li>works on full resolution data, requires additional steps e.g.&nbsp;to try out things on lower resolution</li>
<li>currently being rewritten (see https://github.com/rspatial/terra)</li>
</ul>
<p><code>stars</code> <span class="citation" data-cites="stars">(<a href="#ref-stars" role="doc-biblioref">Pebesma 2019</a>)</span> (see parallel session)</p>
<ul>
<li>arbitrary dimensions</li>
<li>assumes a data cube as input (does not do spatial mosaicing, temporal aggregation)</li>
<li>has vector data cubes</li>
<li>lazy evaluation approach, compute only the pixels you see.</li>
</ul></section><section id="first-steps-with-gdalcubes" class="level2"><h2 class="anchored" data-anchor-id="first-steps-with-gdalcubes">First Steps with gdalcubes</h2>
<p>gdalcubes is a relatively new R package that mostly wraps functions written in C++. It uses GDAL to read, write, and warp images, but understands date/time and how complex satellite image data products are organized. To get started, please install the gdalcubes package from CRAN with:</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/install_d12b81957e5cdd2683f7d164dc6b64f0">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="fu">install.packages</span>(<span class="st">"gdalcubes"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can load the package and make sure that all computations later in this tutorial use up to 8 parallel processes with:</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/setup_gdalcubes_88d074e6c314bc0276a5193dd80e4d07">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="fu">library</span>(gdalcubes)</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="fu">gdalcubes_options</span>(<span class="at">parallel =</span> <span class="dv">8</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Please notice that this tutorial needs package version &gt;= 0.6.0, which you can check by running:</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/pkgversion_b911e03b03d824b63121b78c43ad7e17">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="fu">packageVersion</span>(<span class="st">"gdalcubes"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] '0.6.4'</code></pre>
</div>
</div>
</section><section id="creating-an-image-collection" class="level2"><h2 class="anchored" data-anchor-id="creating-an-image-collection">Creating an Image Collection</h2>
<p>To analyze our sample dataset, we must first tell gdalcubes, which files belong to the image collection, and where to find them.</p>
<p>At first, we simply list (recursively) all GeoTIFF files in the directory with the Landsat 8 images:</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8files_b8e471f181dc8f120289509dc61e5e60">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>L8.files <span class="ot">=</span> <span class="fu">list.files</span>(<span class="st">"L8_Amazon"</span>, <span class="at">pattern =</span> <span class="st">".tif"</span>, <span class="at">recursive =</span> <span class="cn">TRUE</span>, <span class="at">full.names =</span> <span class="cn">TRUE</span>) </span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="fu">head</span>(L8.files, <span class="dv">15</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "L8_Amazon/LC082260632014071901T1-SC20190715045926/LC08_L1TP_226063_20140719_20170421_01_T1_pixel_qa.tif"  
 [2] "L8_Amazon/LC082260632014071901T1-SC20190715045926/LC08_L1TP_226063_20140719_20170421_01_T1_radsat_qa.tif" 
 [3] "L8_Amazon/LC082260632014071901T1-SC20190715045926/LC08_L1TP_226063_20140719_20170421_01_T1_sr_aerosol.tif"
 [4] "L8_Amazon/LC082260632014071901T1-SC20190715045926/LC08_L1TP_226063_20140719_20170421_01_T1_sr_band1.tif"  
 [5] "L8_Amazon/LC082260632014071901T1-SC20190715045926/LC08_L1TP_226063_20140719_20170421_01_T1_sr_band2.tif"  
 [6] "L8_Amazon/LC082260632014071901T1-SC20190715045926/LC08_L1TP_226063_20140719_20170421_01_T1_sr_band3.tif"  
 [7] "L8_Amazon/LC082260632014071901T1-SC20190715045926/LC08_L1TP_226063_20140719_20170421_01_T1_sr_band4.tif"  
 [8] "L8_Amazon/LC082260632014071901T1-SC20190715045926/LC08_L1TP_226063_20140719_20170421_01_T1_sr_band5.tif"  
 [9] "L8_Amazon/LC082260632014071901T1-SC20190715045926/LC08_L1TP_226063_20140719_20170421_01_T1_sr_band6.tif"  
[10] "L8_Amazon/LC082260632014071901T1-SC20190715045926/LC08_L1TP_226063_20140719_20170421_01_T1_sr_band7.tif"  
[11] "L8_Amazon/LC082260632014082001T1-SC20190715051515/LC08_L1TP_226063_20140820_20170420_01_T1_pixel_qa.tif"  
[12] "L8_Amazon/LC082260632014082001T1-SC20190715051515/LC08_L1TP_226063_20140820_20170420_01_T1_radsat_qa.tif" 
[13] "L8_Amazon/LC082260632014082001T1-SC20190715051515/LC08_L1TP_226063_20140820_20170420_01_T1_sr_aerosol.tif"
[14] "L8_Amazon/LC082260632014082001T1-SC20190715051515/LC08_L1TP_226063_20140820_20170420_01_T1_sr_band1.tif"  
[15] "L8_Amazon/LC082260632014082001T1-SC20190715051515/LC08_L1TP_226063_20140820_20170420_01_T1_sr_band2.tif"  </code></pre>
</div>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a><span class="fu">sum</span>(<span class="fu">file.size</span>(L8.files)) <span class="sc">/</span> <span class="dv">1000</span><span class="sc">^</span><span class="dv">3</span> <span class="co"># gigabytes</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2.012341</code></pre>
</div>
</div>
<p>We see that every image is represented by a directory, with individual files for spectral bands. We can then add all images to an image collection with:</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8col_e1d4fff7f7f5997ee0f00906ace53f68">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>L8.col <span class="ot">=</span> <span class="fu">create_image_collection</span>(L8.files, <span class="at">format =</span> <span class="st">"L8_SR"</span>, <span class="at">out_file =</span> <span class="st">"L8.db"</span>)</span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="co"># L8.col = image_collection("L8.db") </span></span>
<span id="cb10-3"><a href="#cb10-3"></a>L8.col</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Image collection object, referencing 180 images with 10 bands
Images:
                                      name      left       top    bottom
1 LC08_L1TP_226063_20140719_20170421_01_T1 -54.15776 -3.289862 -5.392073
2 LC08_L1TP_226063_20140820_20170420_01_T1 -54.16858 -3.289828 -5.392054
3 LC08_L1GT_226063_20160114_20170405_01_T2 -54.16317 -3.289845 -5.392064
4 LC08_L1TP_226063_20160724_20170322_01_T1 -54.16317 -3.289845 -5.392064
5 LC08_L1TP_226063_20170609_20170616_01_T1 -54.17399 -3.289810 -5.392044
6 LC08_L1TP_226063_20170711_20170726_01_T1 -54.15506 -3.289870 -5.392083
      right            datetime        srs
1 -52.10338 2014-07-19T00:00:00 EPSG:32622
2 -52.11418 2014-08-20T00:00:00 EPSG:32622
3 -52.10878 2016-01-14T00:00:00 EPSG:32622
4 -52.10878 2016-07-24T00:00:00 EPSG:32622
5 -52.11958 2017-06-09T00:00:00 EPSG:32622
6 -52.09798 2017-07-11T00:00:00 EPSG:32622
[ omitted 174 images ] 

Bands:
        name offset scale unit       nodata image_count
1    AEROSOL      0     1                           180
2        B01      0     1      -9999.000000         180
3        B02      0     1      -9999.000000         180
4        B03      0     1      -9999.000000         180
5        B04      0     1      -9999.000000         180
6        B05      0     1      -9999.000000         180
7        B06      0     1      -9999.000000         180
8        B07      0     1      -9999.000000         180
9   PIXEL_QA      0     1                           180
10 RADSAT_QA      0     1                           180</code></pre>
</div>
</div>
<p>This opens all provided files once, reads some relevant metadata (spatial extent, reference system, recording date/time, and how the file relates to the spectral bands of the data product). The <code>format</code> argument describes, how this information can be extracted. The gdalcubes package comes with a set of predefined <strong>image collection formats</strong> for particular data products. We can list available formats with:</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/colformats_65f557e98d02a8e0f5fa565fc8ec3f40">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a><span class="fu">collection_formats</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   CHIRPS_v2_0_daily_p05_tif | Image collection format for CHIRPS v 2.0 daily
                             | global precipitation dataset (0.05 degrees
                             | resolution) from GeoTIFFs, expects list of .tif
                             | or .tif.gz files as input. [TAGS: CHIRPS,
                             | precipitation]
 CHIRPS_v2_0_monthly_p05_tif | Image collection format for CHIRPS v 2.0 monthly
                             | global precipitation dataset (0.05 degrees
                             | resolution) from GeoTIFFs, expects list of .tif
                             | or .tif.gz files as input. [TAGS: CHIRPS,
                             | precipitation]
           ESA_CCI_SM_ACTIVE | Collection format for ESA CCI soil moisture
                             | active product (version 4.7) [TAGS: Soil
                             | Moisture, ESA, CCI]
          ESA_CCI_SM_PASSIVE | Collection format for ESA CCI soil moisture
                             | passive product (version 4.7) [TAGS: Soil
                             | Moisture, ESA, CCI]
   GPM_IMERG_3B_DAY_GIS_V06A | Collection format for daily
                             | IMERG_3B_DAY_GIS_V06A data [TAGS: Precipitation,
                             | GPM, IMERG]
                     L8_L1TP | Collection format for Landsat 8 Level 1 TP
                             | product [TAGS: Landsat, USGS, Level 1, NASA]
                       L8_SR | Collection format for Landsat 8 surface
                             | reflectance product [TAGS: Landsat, USGS, Level
                             | 2, NASA, surface reflectance]
                     MxD09GA | Collection format for selected bands from the
                             | MODIS MxD09GA (Aqua and Terra) product [TAGS:
                             | MODIS, surface reflectance]
                     MxD10A2 | Collection format for selected bands from the
                             | MODIS MxD10A2 (Aqua and Terra) v006 Snow Cover
                             | product [TAGS: MODIS, Snow Cover]
                     MxD11A1 | Collection format for selected bands from the
                             | MODIS MxD11A2 (Aqua and Terra) v006 Land Surface
                             | Temperature product [TAGS: MODIS, LST]
                     MxD11A2 | Collection format for selected bands from the
                             | MODIS MxD11A2 (Aqua and Terra) v006 Land Surface
                             | Temperature product [TAGS: MODIS, LST]
                     MxD13A2 | Collection format for selected bands from the
                             | MODIS MxD13A2 (Aqua and Terra) product [TAGS:
                             | MODIS, VI, NDVI, EVI]
                     MxD13A3 | Collection format for selected bands from the
                             | MODIS MxD13A3 (Aqua and Terra) product [TAGS:
                             | MODIS, VI, NDVI, EVI]
                     MxD13Q1 | Collection format for selected bands from the
                             | MODIS MxD13Q1 (Aqua and Terra) product [TAGS:
                             | MODIS, VI, NDVI, EVI]
                     MxD14A2 | Collection format for the MODIS MxD14A2 (Aqua
                             | and Terra) product [TAGS: MODIS, Fire]
PlanetScope_3B_AnalyticMS_SR | Image collection format for PlanetScope 4-band
                             | scenes [TAGS: PlanetScope, BOA, Surface
                             | Reflectance]
               Sentinel2_L1C | Image collection format for Sentinel 2 Level 1C
                             | data as downloaded from the Copernicus Open
                             | Access Hub, expects a list of file paths as
                             | input. The format works on original ZIP
                             | compressed as well as uncompressed imagery.
                             | [TAGS: Sentinel, Copernicus, ESA, TOA]
           Sentinel2_L1C_AWS | Image collection format for Sentinel 2 Level 1C
                             | data in AWS [TAGS: Sentinel, Copernicus, ESA,
                             | TOA]
               Sentinel2_L2A | Image collection format for Sentinel 2 Level 2A
                             | data as downloaded from the Copernicus Open
                             | Access Hub, expects a list of file paths as
                             | input. The format should work on original ZIP
                             | compressed as well as uncompressed imagery.
                             | [TAGS: Sentinel, Copernicus, ESA, BOA, Surface
                             | Reflectance]
         Sentinel2_L2A_THEIA | Image collection format for Sentinel 2 Level 2A
                             | data as downloaded from Theia. [TAGS: Sentinel,
                             | ESA, Flat Reflectance, Theia]</code></pre>
</div>
</div>
<p>The number of available formats is still rather limited, but continues to grow and is extensible (using <code>add_collection_format()</code>). In fact, a collection format is a single JSON (JavaScript Object Notation) file, describing some rules how to extract e.g.&nbsp;date/time, and bands from filenames (examples at https://github.com/appelmar/gdalcubes_formats). Writing collection formats for your own non-standard datasets is not too difficult and documented <a href="https://gdalcubes.github.io/docs/collection_formats.html">here</a>.</p>
<p>In our example, we used the predefined format <code>"L8_SR"</code> for Landsat 8 surface reflectance data as downloaded from the <a href="https://espa.cr.usgs.gov">USGS portal</a>.</p>
<p>The creation of image collections is typically done only once. We can add images to an existing collection with <code>add_images()</code>.</p>
<p>We can extract the spatiotemporal extent of the collection with:</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8extent_50af9867b62d8bd0efa245009eb0329d">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a><span class="fu">extent</span>(L8.col, <span class="at">srs=</span><span class="st">"EPSG:4326"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>$left
[1] -59.12746

$right
[1] -52.09798

$top
[1] -1.844241

$bottom
[1] -6.84404

$t0
[1] "2013-06-12T00:00:00"

$t1
[1] "2019-07-06T00:00:00"</code></pre>
</div>
</div>
</section><section id="defining-a-data-cube-view-a-virtual-data-cube" class="level2"><h2 class="anchored" data-anchor-id="defining-a-data-cube-view-a-virtual-data-cube">Defining a <em>Data Cube View</em>: A Virtual Data Cube</h2>
<p>We can define a target data cube by its geometry, i.e., the spatiotemporal extent, the spatial reference system, the spatial size, and the temporal duration of cells. We call this a <em>data cube view</em>, i.e.&nbsp;the geometry of a cube without connecting it to any data. To create a data cube view, we can use the <code>cube_view()</code> function:</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8cubeview_3e7d5ebbb4f01fad23bf0db20d4f39e4">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a><span class="co"># Coarse resolution overview</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>v.overview<span class="fl">.500</span>m <span class="ot">=</span> <span class="fu">cube_view</span>(<span class="at">srs=</span><span class="st">"EPSG:3857"</span>, <span class="at">extent=</span>L8.col, <span class="at">dx=</span><span class="dv">500</span>, <span class="at">dy=</span><span class="dv">500</span>, <span class="at">dt =</span> <span class="st">"P1Y"</span>, <span class="at">resampling=</span><span class="st">"average"</span>, <span class="at">aggregation=</span><span class="st">"median"</span>)</span>
<span id="cb16-3"><a href="#cb16-3"></a>v.overview<span class="fl">.500</span>m</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>A data cube view object

Dimensions:
                low              high count pixel_size
t        2013-01-01        2019-12-31     7        P1Y
y -763764.387686915 -205264.387686915  1117        500
x -6582280.06164712 -5799280.06164712  1566        500

SRS: "EPSG:3857"
Temporal aggregation method: "median"
Spatial resampling method: "average"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a>v.subarea<span class="fl">.60</span>m <span class="ot">=</span> <span class="fu">cube_view</span>(<span class="at">extent=</span><span class="fu">list</span>(<span class="at">left=</span><span class="sc">-</span><span class="dv">6180000</span>, <span class="at">right=</span><span class="sc">-</span><span class="dv">6080000</span>, <span class="at">bottom=</span><span class="sc">-</span><span class="dv">550000</span>, <span class="at">top=</span><span class="sc">-</span><span class="dv">450000</span>, </span>
<span id="cb18-2"><a href="#cb18-2"></a>   <span class="at">t0=</span><span class="st">"2014-01-01"</span>, <span class="at">t1=</span><span class="st">"2018-12-31"</span>), <span class="at">dt=</span><span class="st">"P1Y"</span>, <span class="at">dx=</span><span class="dv">60</span>, <span class="at">dy=</span><span class="dv">60</span>, <span class="at">srs=</span><span class="st">"EPSG:3857"</span>, </span>
<span id="cb18-3"><a href="#cb18-3"></a>   <span class="at">aggregation =</span> <span class="st">"median"</span>, <span class="at">resampling =</span> <span class="st">"average"</span>)</span>
<span id="cb18-4"><a href="#cb18-4"></a>v.subarea<span class="fl">.60</span>m</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>A data cube view object

Dimensions:
         low       high count pixel_size
t 2014-01-01 2018-12-31     5        P1Y
y    -550010    -449990  1667         60
x   -6180010   -6079990  1667         60

SRS: "EPSG:3857"
Temporal aggregation method: "median"
Spatial resampling method: "average"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a>v.subarea<span class="fl">.60</span>m.daily <span class="ot">=</span>  <span class="fu">cube_view</span>(<span class="at">view =</span> v.subarea<span class="fl">.60</span>m, <span class="at">dt=</span><span class="st">"P1D"</span>) </span>
<span id="cb20-2"><a href="#cb20-2"></a>v.subarea<span class="fl">.60</span>m.daily</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>A data cube view object

Dimensions:
         low       high count pixel_size
t 2014-01-01 2018-12-31  1826        P1D
y    -550010    -449990  1667         60
x   -6180010   -6079990  1667         60

SRS: "EPSG:3857"
Temporal aggregation method: "median"
Spatial resampling method: "average"</code></pre>
</div>
</div>
<p>Notice that the data cube view does not contain any information on bands, because it is independent from particular data products.</p>
</section><section id="creating-data-cubes" class="level2"><h2 class="anchored" data-anchor-id="creating-data-cubes">Creating Data Cubes</h2>
<p>Having defined an <em>image collection</em>, and a <em>data cube view</em>, a data cube is simply the combination of the two. We can create a data cube with the <code>raster_cube()</code> function:</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8datacube_b957684ff3c4255b1934dde738508625">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1"></a>L8.cube.overview <span class="ot">=</span> <span class="fu">raster_cube</span>(L8.col, v.overview<span class="fl">.500</span>m)</span>
<span id="cb22-2"><a href="#cb22-2"></a>L8.cube.overview</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>A data cube proxy object

Dimensions:
                low              high count pixel_size chunk_size
t        2013-01-01        2019-12-31     7        P1Y          1
y -763764.387686915 -205264.387686915  1117        500        384
x -6582280.06164712 -5799280.06164712  1566        500        384

Bands:
        name offset scale nodata unit
1    AEROSOL      0     1    NaN     
2        B01      0     1    NaN     
3        B02      0     1    NaN     
4        B03      0     1    NaN     
5        B04      0     1    NaN     
6        B05      0     1    NaN     
7        B06      0     1    NaN     
8        B07      0     1    NaN     
9   PIXEL_QA      0     1    NaN     
10 RADSAT_QA      0     1    NaN     </code></pre>
</div>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1"></a>L8.cube.subarea <span class="ot">=</span> <span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m)</span>
<span id="cb24-2"><a href="#cb24-2"></a>L8.cube.subarea</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>A data cube proxy object

Dimensions:
         low       high count pixel_size chunk_size
t 2014-01-01 2018-12-31     5        P1Y          1
y    -550010    -449990  1667         60        448
x   -6180010   -6079990  1667         60        448

Bands:
        name offset scale nodata unit
1    AEROSOL      0     1    NaN     
2        B01      0     1    NaN     
3        B02      0     1    NaN     
4        B03      0     1    NaN     
5        B04      0     1    NaN     
6        B05      0     1    NaN     
7        B06      0     1    NaN     
8        B07      0     1    NaN     
9   PIXEL_QA      0     1    NaN     
10 RADSAT_QA      0     1    NaN     </code></pre>
</div>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1"></a>L8.cube.subarea.daily <span class="ot">=</span> <span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m.daily)</span>
<span id="cb26-2"><a href="#cb26-2"></a>L8.cube.subarea.daily</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>A data cube proxy object

Dimensions:
         low       high count pixel_size chunk_size
t 2014-01-01 2018-12-31  1826        P1D          1
y    -550010    -449990  1667         60        448
x   -6180010   -6079990  1667         60        448

Bands:
        name offset scale nodata unit
1    AEROSOL      0     1    NaN     
2        B01      0     1    NaN     
3        B02      0     1    NaN     
4        B03      0     1    NaN     
5        B04      0     1    NaN     
6        B05      0     1    NaN     
7        B06      0     1    NaN     
8        B07      0     1    NaN     
9   PIXEL_QA      0     1    NaN     
10 RADSAT_QA      0     1    NaN     </code></pre>
</div>
</div>
<p>This is very cheap, simply returning <em>proxy</em> objects, but not reading any image data. The package delays the computational intensive parts as much as possible (e.g., until users call <code><a href="https://rdrr.io/r/graphics/plot.default.html">plot()</a></code>). The returned object knows about the bands of the data product. We can use <code>select_bands()</code> to get only the bands we are interested in:</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8rgb_1a3020da6f6a269e1994a96dd173b1c3">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1"></a>L8.cube.overview.rgb <span class="ot">=</span> <span class="fu">select_bands</span>(L8.cube.overview, <span class="fu">c</span>(<span class="st">"B02"</span>, <span class="st">"B03"</span>, <span class="st">"B04"</span>))</span>
<span id="cb28-2"><a href="#cb28-2"></a>L8.cube.overview.rgb</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>A data cube proxy object

Dimensions:
                low              high count pixel_size chunk_size
t        2013-01-01        2019-12-31     7        P1Y          1
y -763764.387686915 -205264.387686915  1117        500        384
x -6582280.06164712 -5799280.06164712  1566        500        384

Bands:
  name offset scale nodata unit
1  B02      0     1    NaN     
2  B03      0     1    NaN     
3  B04      0     1    NaN     </code></pre>
</div>
</div>
<p>There are some utility functions on data cubes, including:</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/datacubefun_ee704a953efc5de8ba8733b670ef44ab">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1"></a><span class="fu">names</span>(L8.cube.overview.rgb)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "B02" "B03" "B04"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1"></a><span class="fu">srs</span>(L8.cube.overview.rgb)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "EPSG:3857"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1"></a><span class="fu">bands</span>(L8.cube.overview.rgb)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  name offset scale nodata unit
1  B02      0     1    NaN     
2  B03      0     1    NaN     
3  B04      0     1    NaN     </code></pre>
</div>
</div>
</section><section id="plotting-data-cubes" class="level2"><h2 class="anchored" data-anchor-id="plotting-data-cubes">Plotting Data Cubes</h2>
<p>The plot function can be used to visualize data cubes. Calling <code><a href="https://rdrr.io/r/graphics/plot.default.html">plot()</a></code> will start reading and processing the data:</p>
<p>For a simple RGB plot, we use the <code>rgb</code> argument to specify which bands correspond to the red, green, and blue channels, and specify the black and white points of the channels (to control contrast and brightness) in <code>zlim</code>.</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8plot1_107bebbcee87f43f8964c6c5a44d67b4">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1"></a><span class="fu">plot</span>(L8.cube.overview.rgb, <span class="at">rgb=</span><span class="dv">3</span><span class="sc">:</span><span class="dv">1</span>, <span class="at">zlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1500</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Landsat8_getting_started_files/figure-html/L8plot1-1.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1"></a><span class="fu">plot</span>(<span class="fu">select_bands</span>(L8.cube.subarea, <span class="fu">c</span>(<span class="st">"B02"</span>, <span class="st">"B03"</span>, <span class="st">"B04"</span>)), <span class="at">rgb=</span><span class="dv">3</span><span class="sc">:</span><span class="dv">1</span>, <span class="at">zlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1500</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Landsat8_getting_started_files/figure-html/L8plot1-2.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Notice that we can also plot bands individually, creating a two-dimensional plot layout of bands and time. Using <code>key.pos = 1</code>, and <code>col= viridis::viridis</code>, we plot a legend at the bottom of the plot, and use the viridis color scales (this requires the viridis package).</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8plot2_ad4403e4ac038a840b755c1210d874d1">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1"></a><span class="fu">plot</span>(L8.cube.overview.rgb, <span class="at">zlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1500</span>), <span class="at">key.pos=</span><span class="dv">1</span>, <span class="at">col=</span>viridis<span class="sc">::</span>viridis, <span class="at">t=</span><span class="dv">2</span><span class="sc">:</span><span class="dv">5</span>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Landsat8_getting_started_files/figure-html/L8plot2-1.png" class="img-fluid" width="672"></p>
</div>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1"></a><span class="fu">plot</span>(<span class="fu">select_bands</span>(<span class="fu">raster_cube</span>(L8.col,<span class="at">view =</span> v.subarea<span class="fl">.60</span>m), <span class="fu">c</span>(<span class="st">"B05"</span>)),<span class="at">col=</span>viridis<span class="sc">::</span>viridis,  <span class="at">zlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">6000</span>), <span class="at">key.pos=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Landsat8_getting_started_files/figure-html/L8plot2-2.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Plotting an identical data cube twice, with different visualization arguments <code>zlim</code>, <code>col</code>, and others will not need to reprocess the data cube again. <code><a href="https://rdrr.io/r/graphics/plot.default.html">plot()</a></code> internally writes netCDF files to a temporary directory and remembers that a specific cube is already available.</p>
<p>The <code><a href="https://rdrr.io/r/graphics/plot.default.html">plot()</a></code> function also considers different types of data cubes. For example, if the number of cells in x and y direction equals one, we get a simple time series plot, as we will see later in this tutorial.</p>
<section id="animations" class="level3"><h3 class="anchored" data-anchor-id="animations">Animations</h3>
<p>The data cube representation makes it straightforward to create animations, by plotting time slices of the cube individually, and use these plots as animation frames:</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8anim1_5e5f5d200acd54bebfad101efc5651ea">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1"></a><span class="fu">animate</span>(<span class="fu">select_bands</span>(<span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m), <span class="fu">c</span>(<span class="st">"B02"</span>,<span class="st">"B03"</span>,<span class="st">"B04"</span>)), <span class="at">rgb=</span><span class="dv">3</span><span class="sc">:</span><span class="dv">1</span>, <span class="at">zlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1500</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "/tmp/Rtmp6NBFI3/file2846660b6cac.gif"</code></pre>
</div>
</div>
</section></section><section id="exporting-data-cubes-to-disk" class="level2"><h2 class="anchored" data-anchor-id="exporting-data-cubes-to-disk">Exporting Data Cubes to Disk</h2>
<p>Sometimes we want to process data cubes further, e.g.&nbsp;with external software. We can export data cubes either as single netCDF files, or as a collection of GeoTIFF files, where each time-slice of a cube will be stored as one (multiband) file.</p>
<p>Both, netCDF and GeoTIFF export support <em>compression</em>, and <em>packing</em> (converting double precision numeric values to smaller integer types by applying an offset and scale) to reduce the file size if needed (see documentation at <code>?write_ncdf</code>, and <code>?write_tif</code>).</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8export_7e962bb9e0d07806e9ff8140f33cdc8e">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1"></a><span class="fu">gdalcubes_options</span>(<span class="at">ncdf_compression_level =</span> <span class="dv">1</span>)</span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="fu">write_ncdf</span>(L8.cube.overview.rgb, <span class="fu">file.path</span>(<span class="st">"~/Desktop"</span>, <span class="fu">basename</span>(<span class="fu">tempfile</span>(<span class="at">fileext =</span> <span class="st">".nc"</span>))))</span>
<span id="cb42-3"><a href="#cb42-3"></a><span class="fu">gdalcubes_options</span>(<span class="at">ncdf_compression_level =</span> <span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>write_tif()</code> and <code>write_ncdf()</code> both return the path(s) to created file(s) as a character vector.</p>
</section><section id="interfacing-existing-r-packages" class="level2"><h2 class="anchored" data-anchor-id="interfacing-existing-r-packages">Interfacing Existing R Packages</h2>
<p>The package comes with a function <code>as_stars()</code> to convert data cubes to <code>stars</code> objects <span class="citation" data-cites="stars">(<a href="#ref-stars" role="doc-biblioref">Pebesma 2019</a>)</span>, data cubes supporting any number of dimensions, and even vector data cubes.</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8stars_b86bcd94d95fe84458555ef99c1a60aa">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1"></a><span class="fu">library</span>(stars)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: abind</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: sf</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE</code></pre>
</div>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1"></a>x <span class="ot">=</span> <span class="fu">st_as_stars</span>(</span>
<span id="cb47-2"><a href="#cb47-2"></a>    <span class="fu">select_bands</span>(</span>
<span id="cb47-3"><a href="#cb47-3"></a>      <span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m), <span class="st">"B05"</span>))</span>
<span id="cb47-4"><a href="#cb47-4"></a>x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>stars object with 3 dimensions and 1 attribute
attribute(s), summary of first 1e+05 cells:
      Min.  1st Qu.   Median     Mean  3rd Qu. Max.
B05  296.5 2984.992 3207.546 3226.604 3459.003 5099
dimension(s):
     from   to   offset delta                   refsys point
x       1 1667 -6180010    60 WGS 84 / Pseudo-Mercator    NA
y       1 1667  -449990   -60 WGS 84 / Pseudo-Mercator    NA
time    1    5       NA    NA                  POSIXct FALSE
                                                  values x/y
x                                                   NULL [x]
y                                                   NULL [y]
time [2014-01-01,2015-01-01),...,[2018-01-01,2019-01-01)    </code></pre>
</div>
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1"></a><span class="fu">plot</span>(x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>downsample set to 2</code></pre>
</div>
<div class="cell-output-display">
<p><img src="Landsat8_getting_started_files/figure-html/L8stars-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The resulting object considers bands as array attributes that can be converted to a new dimension e.g.&nbsp;with <code><a href="https://r-spatial.github.io/stars/reference/redimension.html">stars::st_redimension()</a></code>.</p>
<p>If the raster cube has only a single band, or a single time slice, it is also possible to convert it to a raster (stack), by using <code>write_tif()</code>:</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8raster_b094658a50fdd061d0a7036c8d461196">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1"></a>x <span class="ot">=</span> raster<span class="sc">::</span><span class="fu">stack</span>(</span>
<span id="cb51-2"><a href="#cb51-2"></a>  <span class="fu">write_tif</span>(</span>
<span id="cb51-3"><a href="#cb51-3"></a>    <span class="fu">select_bands</span>(</span>
<span id="cb51-4"><a href="#cb51-4"></a>      <span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m), <span class="st">"B05"</span>)))</span>
<span id="cb51-5"><a href="#cb51-5"></a>x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>class      : RasterStack 
dimensions : 1667, 1667, 2778889, 5  (nrow, ncol, ncell, nlayers)
resolution : 60, 60  (x, y)
extent     : -6180010, -6079990, -550010, -449990  (xmin, xmax, ymin, ymax)
crs        : +proj=merc +a=6378137 +b=6378137 +lat_ts=0 +lon_0=0 +x_0=0 +y_0=0 +k=1 +units=m +nadgrids=@null +wktext +no_defs 
names      : B05.1, B05.2, B05.3, B05.4, B05.5 </code></pre>
</div>
</div>
</section><section id="more-data-cube-creation-options" class="level2"><h2 class="anchored" data-anchor-id="more-data-cube-creation-options">More Data Cube Creation Options</h2>
<p>The <code>raster_cube()</code> function receives two further optional arguments.</p>
<p>The <code>mask</code> argument can be used to apply image masks during construction of the data cube if the data products includes a mask band (e.g.&nbsp;for clouds, cloud shadows, or general quality flags). To define a mask, we typically call the <code>image_mask()</code> function. This function expects the name of the mask band as its first <code>band</code> argument. Additionally, we can either pass a vector of values that are masked (all bands set to NA if the specified <code>band</code> has one of the provided values) as the <code>values</code> argument, or give a range of mask values by passing minimum and maximum values as <code>min</code> and <code>max</code> arguments. Masks can be inverted by setting <code>invert = TRUE</code>. For bit field masks, it is possible to extract specific bits (applying a logical AND) of the band values, before comparing them to the values or range of the mask.</p>
<p>The example below will mask all pixels with a <code>"PIXEL_QA"</code> value different from the provided values (taken from the Landsat 8 handbook).</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8masking_685959817bad0a284dd667440ef5268e">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1"></a>L8.clear_mask <span class="ot">=</span> <span class="fu">image_mask</span>(<span class="st">"PIXEL_QA"</span>, <span class="at">values=</span><span class="fu">c</span>(<span class="dv">322</span>, <span class="dv">386</span>, <span class="dv">834</span>, <span class="dv">898</span>, <span class="dv">1346</span>, <span class="dv">324</span>, <span class="dv">388</span>, <span class="dv">836</span>, <span class="dv">900</span>, <span class="dv">1348</span>), <span class="at">invert =</span> <span class="cn">TRUE</span>)</span>
<span id="cb53-2"><a href="#cb53-2"></a>x <span class="ot">=</span> <span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m, <span class="at">mask=</span>L8.clear_mask) </span>
<span id="cb53-3"><a href="#cb53-3"></a>x <span class="ot">=</span> <span class="fu">select_bands</span>(x, <span class="fu">c</span>(<span class="st">"B02"</span>,<span class="st">"B03"</span>,<span class="st">"B04"</span>))</span>
<span id="cb53-4"><a href="#cb53-4"></a><span class="fu">animate</span>(x, <span class="at">rgb=</span><span class="dv">3</span><span class="sc">:</span><span class="dv">1</span>, <span class="at">zlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1500</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "/tmp/Rtmp6NBFI3/file2846bea32ee.gif"</code></pre>
</div>
</div>
<p>The <code>chunking</code> argument defines the size of data cube chunks as a vector with three integer values for the number of pixels in time, y, and x directions respectively. Chunks are read completely into main memory, i.e., smaller chunks will generally reduce the main memory consumption. The size of chunks also has an effect on parallelization. Internally, chunks of the target data cube are read and processed independently, potentially by multiple threads. However, the effect of the chunk size on the performance is much more complex and depends on how we process the data (e.g., time series vs.&nbsp;time slices oriented), and how the data is stored. Some data formats e.g.&nbsp;do not allow efficient range selection reads whereas others do.</p>
<hr></section></section><section id="exercises-i" class="level1"><h1>Exercises (i)</h1>
<ol type="1">
<li><p>Start R. If not yet done, install the <code>gdalcubes</code> package from CRAN, and load it.</p></li>
<li><p>If not yet done, download the sample dataset from https://hs-bochum.sciebo.de/s/8XcKAmPfPGp2CYh/download and unzip.</p></li>
<li><p>Create an image collection from all GeoTIFF files in the unzipped directory.</p></li>
<li><p>Create a <em>yearly</em> data cube from the image collection, covering the full spatiotemporal extent at 1 km resolution, using a <em>Brazil Mercator</em> projection (EPSG:5641).</p></li>
<li><p>Select the near infrared band (<code>"B05"</code>) and plot the cube.</p></li>
<li><p>Create a false-color image for the year 2017, using the red (<code>"B04"</code>), swir2 (<code>"B07"</code>), and blue (<code>"B02"</code>) bands as red, green, and blue channels. You can select the year 2017 by creating a new data cube view (derived from the previous view, and setting both <code>t0 = "2017"</code>, and <code>t1 = "2017"</code>).</p></li>
</ol>
<hr></section><section id="part-ii-on-the-fly-processing-of-data-cubes" class="level1"><h1>Part II: On-the-fly Processing of Data Cubes</h1>
<p>The gdalcubes package comes with some built-in operations on data cubes. The following operations produce a derived data cube from one or more input data cubes.</p>
<table class="table">
<colgroup>
<col style="width: 20%">
<col style="width: 80%">
</colgroup>
<thead><tr class="header">
<th style="text-align: left;">Operation</th>
<th style="text-align: left;">Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>select_bands</code></td>
<td style="text-align: left;">Select a subset of a data cube’s bands.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>reduce_time</code></td>
<td style="text-align: left;">Apply a reducer function to all pixel time series.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>reduce_space</code></td>
<td style="text-align: left;">Apply a reducer function to all spatial slices of a data cube.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>apply_pixel</code></td>
<td style="text-align: left;">Apply an arithmetic expression to all data cube pixels.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>filter_pixel</code></td>
<td style="text-align: left;">Filter pixels by a logical expressions on band values.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>window_time</code></td>
<td style="text-align: left;">Apply a moving window aggregate or convolution kernel to all pixel time series.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>fill_time</code></td>
<td style="text-align: left;">Fill missing values of a data cube by simple time series interpolation.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>join_bands</code></td>
<td style="text-align: left;">Combine bands of two identically shaped data cubes.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>filter_geom</code></td>
<td style="text-align: left;">Filter pixels by a a spatial polygon.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>crop</code></td>
<td style="text-align: left;">Extract a rectangular spatial / temporal / spatiotemporal window.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>select_time</code></td>
<td style="text-align: left;">Select irregular time slices of a data cube.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>slice_time</code></td>
<td style="text-align: left;">Select a single time slice of a data cube.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>slice_space</code></td>
<td style="text-align: left;">select a single time series of a data cube.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>aggregate_time</code></td>
<td style="text-align: left;">Aggregate and/or regularize time series.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>aggregate_space</code></td>
<td style="text-align: left;">Reduce spatial resolution of a cube by applying a spatial aggregation function.</td>
</tr>
</tbody>
</table>
<p>These operations can be chained (e.g., using the pipe operator <code>|&gt;</code>, which passes a left-hand-side R expression as the first argument to the function on the right-hand-side (e.g.&nbsp;<code>rnorm(100) |&gt; mean</code>).</p>
<p>The implementation of these operations in gdalcubes works chunk-wise, i.e.&nbsp;reads only the chunk of the input data cube that is currently needed. This makes sure that only small parts are needed in main memory.</p>
<section id="arithmetic-expressions-on-data-cube-bands" class="level2"><h2 class="anchored" data-anchor-id="arithmetic-expressions-on-data-cube-bands">Arithmetic Expressions on Data Cube Bands</h2>
<p>The <code>apply_pixel()</code> function can be used to apply per-pixel arithmetic expressions on band values of a data cube. Examples include the calculation of vegetation indexes. The function takes a data cube, a string vector of arithmetic expressions, and a vector of result band names as arguments. Below, we derive the normalized difference vegetation index (NDVI) from the red and near infrared (NIR) channel. We can apply multiple expressions at the same time by providing a vector of expressions (and names).</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8ndvi_f01744e2515a4739a2891929ec17da0d">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1"></a>L8.ndvi <span class="ot">=</span> <span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m, <span class="at">mask=</span>L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb55-2"><a href="#cb55-2"></a>  <span class="fu">select_bands</span>(<span class="fu">c</span>(<span class="st">"B04"</span>,<span class="st">"B05"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb55-3"><a href="#cb55-3"></a>  <span class="fu">apply_pixel</span>(<span class="st">"(B05-B04)/(B05+B04)"</span> , <span class="at">names =</span> <span class="st">"NDVI"</span>, <span class="at">keep_bands=</span><span class="cn">FALSE</span>)</span>
<span id="cb55-4"><a href="#cb55-4"></a></span>
<span id="cb55-5"><a href="#cb55-5"></a>L8.ndvi</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>A data cube proxy object

Dimensions:
         low       high count pixel_size chunk_size
t 2014-01-01 2018-12-31     5        P1Y          1
y    -550010    -449990  1667         60        448
x   -6180010   -6079990  1667         60        448

Bands:
  name offset scale nodata unit
1 NDVI      0     1    NaN     </code></pre>
</div>
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1"></a><span class="fu">plot</span>(L8.ndvi, <span class="at">col=</span>viridis<span class="sc">::</span>viridis, <span class="at">zlim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.3</span>,<span class="dv">1</span>), <span class="at">key.pos =</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Landsat8_getting_started_files/figure-html/L8ndvi-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Creating a chain of data cube operations still returns proxy objects, knowing the size and shape of the output data cube, before calling plot will start computations. In the example, we do not need the original bands after computing the NDVI and set <code>keep_bands = FALSE</code> (this is the default).</p>
<p>Similar to <code>apply_pixel()</code> we can filter pixels by arithmetic expressions with <code>filter_pixel()</code>. Values of all bands for pixels not fulfilling a logical expression will be set to NA.</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8nbr_39d27ae1d53e955eb7c1a2daf6f91089">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1"></a><span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m, <span class="at">mask=</span>L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb58-2"><a href="#cb58-2"></a>  <span class="fu">select_bands</span>(<span class="fu">c</span>(<span class="st">"B05"</span>,<span class="st">"B07"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb58-3"><a href="#cb58-3"></a>  <span class="fu">apply_pixel</span>(<span class="st">"(B05-B07)/(B05+B07)"</span> , <span class="at">names =</span> <span class="st">"NBR"</span>) <span class="sc">|&gt;</span></span>
<span id="cb58-4"><a href="#cb58-4"></a>  <span class="fu">filter_pixel</span>(<span class="st">"NBR &lt; 0.5"</span>) <span class="sc">|&gt;</span></span>
<span id="cb58-5"><a href="#cb58-5"></a>  <span class="fu">plot</span>(<span class="at">col=</span>viridis<span class="sc">::</span>viridis, <span class="at">zlim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>,<span class="fl">0.5</span>), <span class="at">key.pos =</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Landsat8_getting_started_files/figure-html/L8nbr-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section><section id="reduction-over-time-and-space" class="level2"><h2 class="anchored" data-anchor-id="reduction-over-time-and-space">Reduction Over Time and Space</h2>
<p>Data cubes can be reduced over the space and time dimensions. The <code>reduce_time()</code> function applies one or more reducer functions over pixel time series, producing a single (multiband) result image, whereas <code>reduce_space()</code> reduces time slices in the cube to single values (per band), resulting in a single (multiband) time series.</p>
<p>The example below derives median NDVI values over all pixel time series.</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8reducetime1_470e5fec6635b148035ca13eb794dcf4">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1"></a><span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m, <span class="at">mask=</span>L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb59-2"><a href="#cb59-2"></a>  <span class="fu">select_bands</span>(<span class="fu">c</span>(<span class="st">"B04"</span>,<span class="st">"B05"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb59-3"><a href="#cb59-3"></a>  <span class="fu">apply_pixel</span>(<span class="st">"(B05-B04)/(B05+B04)"</span>, <span class="at">names =</span> <span class="st">"NDVI"</span>, <span class="at">keep_bands=</span><span class="cn">FALSE</span>) <span class="sc">|&gt;</span></span>
<span id="cb59-4"><a href="#cb59-4"></a>  <span class="fu">reduce_time</span>(<span class="st">"median(NDVI)"</span>) <span class="sc">|&gt;</span></span>
<span id="cb59-5"><a href="#cb59-5"></a>  <span class="fu">plot</span>(<span class="at">col=</span>viridis<span class="sc">::</span>viridis, <span class="at">nbreaks=</span><span class="dv">100</span>, <span class="at">zlim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.3</span>,<span class="dv">1</span>), <span class="at">key.pos =</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Landsat8_getting_started_files/figure-html/L8reducetime1-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Possible reducers include <code>"min"</code>, <code>"mean"</code>, <code>"median"</code>, <code>"max"</code>, <code>"count"</code> (count non-missing values), <code>"sum"</code>, <code>"var"</code> (variance), and <code>"sd"</code> (standard deviation). Reducer expressions are always given as a string starting with the reducer name followed by the band name in parentheses. Notice that it is not possible to apply more complex arithmetic expressions here. It is however possible to mix reducers and bands:</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8reducetime2_69ae51f34193466cdb1e4a9d2e15a3a3">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1"></a><span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m, <span class="at">mask=</span>L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb60-2"><a href="#cb60-2"></a>  <span class="fu">select_bands</span>(<span class="fu">c</span>(<span class="st">"B04"</span>,<span class="st">"B05"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb60-3"><a href="#cb60-3"></a>  <span class="fu">apply_pixel</span>(<span class="st">"(B05-B04)/(B05+B04)"</span>, <span class="at">names =</span> <span class="st">"NDVI"</span>, <span class="at">keep_bands=</span><span class="cn">TRUE</span>) <span class="sc">|&gt;</span></span>
<span id="cb60-4"><a href="#cb60-4"></a>  <span class="fu">reduce_time</span>(<span class="st">"median(NDVI)"</span>, <span class="st">"mean(NDVI)"</span>,<span class="st">"max(B05)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>A data cube proxy object

Dimensions:
         low       high count pixel_size chunk_size
t 2014-01-01 2018-12-31     1        P5Y          1
y    -550010    -449990  1667         60        448
x   -6180010   -6079990  1667         60        448

Bands:
         name offset scale nodata unit
1 NDVI_median      0     1    NaN     
2   NDVI_mean      0     1    NaN     
3     B05_max      0     1    NaN     </code></pre>
</div>
</div>
<p>Results of <code>reduce_space()</code> are plotted as simple time series.</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8space1_17be6805e6f5ce10ce4d97b820e77b72">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1"></a><span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m,  <span class="at">mask=</span>L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb62-2"><a href="#cb62-2"></a>  <span class="fu">select_bands</span>(<span class="fu">c</span>(<span class="st">"B04"</span>,<span class="st">"B05"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb62-3"><a href="#cb62-3"></a>  <span class="fu">apply_pixel</span>(<span class="st">"(B05-B04)/(B05+B04)"</span>, <span class="at">names =</span> <span class="st">"NDVI"</span>) <span class="sc">|&gt;</span></span>
<span id="cb62-4"><a href="#cb62-4"></a>  <span class="fu">reduce_space</span>(<span class="st">"median(NDVI)"</span>, <span class="st">"sd(NDVI)"</span>) <span class="sc">|&gt;</span></span>
<span id="cb62-5"><a href="#cb62-5"></a>  <span class="fu">plot</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Landsat8_getting_started_files/figure-html/L8space1-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The <code>"count"</code> reducer is often very useful to get an initial understanding of an image collection.</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8reducetime_count_c35e6f917f8873c0b8b6690875691239">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1"></a><span class="fu">raster_cube</span>(L8.col, <span class="fu">cube_view</span>(<span class="at">view=</span>v.overview<span class="fl">.500</span>m, <span class="at">dt=</span><span class="st">"P1D"</span>), <span class="at">mask=</span>L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb63-2"><a href="#cb63-2"></a>  <span class="fu">select_bands</span>(<span class="fu">c</span>(<span class="st">"B01"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb63-3"><a href="#cb63-3"></a>  <span class="fu">reduce_time</span>(<span class="st">"count(B01)"</span>) <span class="sc">|&gt;</span></span>
<span id="cb63-4"><a href="#cb63-4"></a>  <span class="fu">plot</span>(<span class="at">key.pos=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Landsat8_getting_started_files/figure-html/L8reducetime_count-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8reducespace_count_311194e38f10f1fc504606ecd871d932">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1"></a><span class="fu">raster_cube</span>(L8.col, <span class="fu">cube_view</span>(<span class="at">view=</span>v.overview<span class="fl">.500</span>m, <span class="at">dt=</span><span class="st">"P1M"</span>), <span class="at">mask=</span>L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb64-2"><a href="#cb64-2"></a>  <span class="fu">select_bands</span>(<span class="st">"B01"</span>) <span class="sc">|&gt;</span></span>
<span id="cb64-3"><a href="#cb64-3"></a>  <span class="fu">reduce_space</span>(<span class="st">"count(B01)"</span>) <span class="sc">|&gt;</span></span>
<span id="cb64-4"><a href="#cb64-4"></a>  <span class="fu">plot</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Landsat8_getting_started_files/figure-html/L8reducespace_count-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>We can see that there are almost no observations during the months from October to May, because the download was limited to images with low cloud percentages.</p>
</section><section id="time-series-methods" class="level2"><h2 class="anchored" data-anchor-id="time-series-methods">Time-series methods</h2>
<p>There are two more built-in functions that operate on individual pixel time series.</p>
<p>The <code>fill_time()</code> function interpolates missing values by preceding or succeeding values (using simple linear or nearest neighbor interpolation, or carrying observations forwards or backwards), The <code>window_time()</code> function can either apply a moving window kernel, or apply a reducer function over moving windows.</p>
<p>In the example below, we sum NDVI changes between subsequent time slices in the data cube, and visualize the result using a diverging color scale from the <code>RColorBrewer</code> package.</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8timeseries_5c59542a8096022b709a8527942a84df">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1"></a><span class="fu">raster_cube</span>(L8.col, <span class="fu">cube_view</span>(<span class="at">view =</span> v.subarea<span class="fl">.60</span>m, <span class="at">extent=</span><span class="fu">list</span>(<span class="at">t0=</span><span class="st">"2014-01"</span>,<span class="at">t1=</span><span class="st">"2018-12"</span>)), <span class="at">mask=</span>L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb65-2"><a href="#cb65-2"></a>  <span class="fu">select_bands</span>(<span class="fu">c</span>(<span class="st">"B04"</span>,<span class="st">"B05"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb65-3"><a href="#cb65-3"></a>  <span class="fu">apply_pixel</span>(<span class="st">"(B05-B04)/(B05+B04)"</span>, <span class="at">names =</span> <span class="st">"NDVI"</span>) <span class="sc">|&gt;</span></span>
<span id="cb65-4"><a href="#cb65-4"></a>  <span class="fu">fill_time</span>(<span class="at">method =</span> <span class="st">"locf"</span>) <span class="sc">|&gt;</span></span>
<span id="cb65-5"><a href="#cb65-5"></a>  <span class="fu">window_time</span>(<span class="at">kernel =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>,<span class="dv">1</span>), <span class="at">window=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">0</span>)) <span class="sc">|&gt;</span></span>
<span id="cb65-6"><a href="#cb65-6"></a>  <span class="fu">reduce_time</span>(<span class="st">"sum(NDVI)"</span>) <span class="sc">|&gt;</span></span>
<span id="cb65-7"><a href="#cb65-7"></a>  <span class="fu">plot</span>(<span class="at">zlim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.4</span>,<span class="fl">0.4</span>),<span class="at">nbreaks =</span> <span class="dv">12</span>, <span class="at">col=</span>RColorBrewer<span class="sc">::</span><span class="fu">brewer.pal</span>(<span class="dv">11</span>, <span class="st">"RdYlBu"</span>), <span class="at">key.pos=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Landsat8_getting_started_files/figure-html/L8timeseries-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section><section id="user-defined-functions" class="level2"><h2 class="anchored" data-anchor-id="user-defined-functions">User-defined Functions</h2>
<p>So far, we have provided expressions and reducers as characters / strings. The reasons was that these methods automatically translate to C++, i.e.&nbsp;are evaluated in the C++ code. In the current version, <code>reduce_time()</code>, and <code>apply_pixel()</code> may also receive R functions as argument. This opens up quite a bunch of things we can do, e.g.&nbsp;using functions from our favorite R packages to process pixel time series. In the example below, we simply fit a line to individual NDVI pixel time series and return its slope (trend).</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/L8udf_a1ddef152337ae1f86e254d014368ab7">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1"></a><span class="fu">raster_cube</span>(L8.col, <span class="fu">cube_view</span>(<span class="at">view =</span> v.subarea<span class="fl">.60</span>m, <span class="at">dx=</span><span class="dv">200</span>), <span class="at">mask =</span> L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb66-2"><a href="#cb66-2"></a>  <span class="fu">select_bands</span>(<span class="fu">c</span>(<span class="st">"B04"</span>,<span class="st">"B05"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb66-3"><a href="#cb66-3"></a>  <span class="fu">apply_pixel</span>(<span class="st">"(B05-B04)/(B05+B04)"</span>, <span class="at">names =</span> <span class="st">"NDVI"</span>) <span class="sc">|&gt;</span></span>
<span id="cb66-4"><a href="#cb66-4"></a>  <span class="fu">reduce_time</span>(<span class="at">names=</span><span class="fu">c</span>(<span class="st">"ndvi_trend"</span>), <span class="at">FUN=</span><span class="cf">function</span>(x) {</span>
<span id="cb66-5"><a href="#cb66-5"></a>    z <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">t=</span><span class="dv">1</span><span class="sc">:</span><span class="fu">ncol</span>(x), <span class="at">ndvi=</span>x[<span class="st">"NDVI"</span>,])</span>
<span id="cb66-6"><a href="#cb66-6"></a>    result <span class="ot">=</span> <span class="cn">NA</span></span>
<span id="cb66-7"><a href="#cb66-7"></a>    <span class="cf">if</span> (<span class="fu">sum</span>(<span class="sc">!</span><span class="fu">is.na</span>(z<span class="sc">$</span>ndvi)) <span class="sc">&gt;</span> <span class="dv">3</span>) {</span>
<span id="cb66-8"><a href="#cb66-8"></a>      result <span class="ot">=</span> <span class="fu">coef</span>(<span class="fu">lm</span>(ndvi <span class="sc">~</span> t, z, <span class="at">na.action =</span> na.exclude))[<span class="dv">2</span>]</span>
<span id="cb66-9"><a href="#cb66-9"></a>    }</span>
<span id="cb66-10"><a href="#cb66-10"></a>    <span class="fu">return</span>(result) </span>
<span id="cb66-11"><a href="#cb66-11"></a>  }) <span class="sc">|&gt;</span></span>
<span id="cb66-12"><a href="#cb66-12"></a>  <span class="fu">plot</span>(<span class="at">key.pos=</span><span class="dv">1</span>, <span class="at">col=</span>viridis<span class="sc">::</span>viridis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="Landsat8_getting_started_files/figure-html/L8udf-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>There is no limit in what we can do in the provided R function, but we must take care of a few things:</p>
<ol type="1">
<li><p>The reducer function is executed in a new R process without access to the current workspace. It is not possible to access variables defined outside of the function and packages must be loaded <strong>within</strong> the function.</p></li>
<li><p>The reducer function <strong>must</strong> always return a vector with the same length (for all time series).</p></li>
<li><p>It is a good idea to think about <code>NA</code> values, i.e.&nbsp;you should check whether the complete time series is <code>NA</code>, and that missing values do not produce errors.</p></li>
</ol></section><section id="for-developers-process-graphs" class="level2"><h2 class="anchored" data-anchor-id="for-developers-process-graphs">For Developers: Process Graphs</h2>
<p>Chaining processes works lazliy; internally gdalcubes creates a <em>process graph</em> of operations that can be serialized as JSON:</p>
<div class="cell" data-hash="Landsat8_getting_started_cache/html/json_7bdf0b5f36654e38c9e0d6e1664aab43">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1"></a><span class="fu">raster_cube</span>(L8.col, <span class="fu">cube_view</span>(<span class="at">view =</span> v.subarea<span class="fl">.60</span>m, <span class="at">extent=</span><span class="fu">list</span>(<span class="at">t0=</span><span class="st">"2014-01"</span>,<span class="at">t1=</span><span class="st">"2018-12"</span>)), <span class="at">mask=</span>L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb67-2"><a href="#cb67-2"></a>  <span class="fu">select_bands</span>(<span class="fu">c</span>(<span class="st">"B04"</span>,<span class="st">"B05"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb67-3"><a href="#cb67-3"></a>  <span class="fu">apply_pixel</span>(<span class="st">"(B05-B04)/(B05+B04)"</span>, <span class="at">names =</span> <span class="st">"NDVI"</span>) <span class="sc">|&gt;</span></span>
<span id="cb67-4"><a href="#cb67-4"></a>  <span class="fu">fill_time</span>(<span class="at">method =</span> <span class="st">"locf"</span>) <span class="sc">|&gt;</span></span>
<span id="cb67-5"><a href="#cb67-5"></a>  <span class="fu">window_time</span>(<span class="at">kernel =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>,<span class="dv">1</span>), <span class="at">window=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">0</span>)) <span class="sc">|&gt;</span></span>
<span id="cb67-6"><a href="#cb67-6"></a>  <span class="fu">reduce_time</span>(<span class="st">"sum(NDVI)"</span>) <span class="sc">|&gt;</span></span>
<span id="cb67-7"><a href="#cb67-7"></a>  <span class="fu">as_json</span>() <span class="sc">|&gt;</span></span>
<span id="cb67-8"><a href="#cb67-8"></a>  <span class="fu">cat</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>{
    "cube_type": "reduce_time",
    "in_cube": {
        "cube_type": "window_time",
        "in_cube": {
            "cube_type": "fill_time",
            "in_cube": {
                "band_names": [
                    "NDVI"
                ],
                "cube_type": "apply_pixel",
                "expr": [
                    "(b05-b04)/(b05+b04)"
                ],
                "in_cube": {
                    "bands": [
                        "B04",
                        "B05"
                    ],
                    "cube_type": "select_bands",
                    "in_cube": {
                        "chunk_size": [
                            1,
                            448,
                            448
                        ],
                        "cube_type": "image_collection",
                        "file": "L8.db",
                        "mask": {
                            "bits": [

                            ],
                            "invert": true,
                            "mask_type": "value_mask",
                            "values": [
                                900,
                                388,
                                324,
                                1346,
                                898,
                                1348,
                                834,
                                836,
                                386,
                                322
                            ]
                        },
                        "mask_band": "PIXEL_QA",
                        "view": {
                            "aggregation": "median",
                            "resampling": "average",
                            "space": {
                                "bottom": -550010,
                                "left": -6180010,
                                "nx": 1667,
                                "ny": 1667,
                                "right": -6079990,
                                "srs": "EPSG:3857",
                                "top": -449990
                            },
                            "time": {
                                "dt": "P1Y",
                                "t0": "2014-01-01",
                                "t1": "2018-12-31"
                            }
                        }
                    }
                },
                "keep_bands": false
            },
            "method": "locf"
        },
        "kernel": [
            -1,
            1
        ],
        "win_size_l": 1,
        "win_size_r": 0
    },
    "reducer_bands": [
        [
            "sum",
            "NDVI"
        ]
    ]
}</code></pre>
</div>
</div>
<p>This is allows to easily recreate chains of operations, and helps e.g.&nbsp;to cache results.</p>
<hr></section></section><section id="summary-limitations-and-future-work" class="level1"><h1>Summary, Limitations, and Future Work</h1>
<p>On-demand raster data cubes as implemented in gdalcubes make it easier to</p>
<ul>
<li>analyze time series of large satellite image collections</li>
<li>experiment on lower resolution first</li>
<li>scale computations</li>
<li>combine data from different sensors / satellites</li>
</ul>
<p>Though gdalcubes works with quite a few datasets directly, others require additional preprocessing. These include radar datasets such as Sentinel-1, or datasets on curvilinear grids, such as Sentinel-5P.</p>
<p>gdalcubes can work directly in cloud computing environments. It uses GDAL to read images and hence can use GDAL’s virtual file systems to access data on object storage (e.g.&nbsp;AWS S3 buckets). Processing cubes in distributed (cloud) computing environments is a bit more difficult and is current work in progress.</p>
<p>gdalcubes is a pretty young tool, there are many ideas still to be implemented (e.g.&nbsp;Python interface, user-defined function support for further operations, interfacing image processing libraries such as Orfeo Toolbox, using gdalcubes as a fully open source <a href="https://openeo.org/">OpenEO</a> backend, …).</p>
<p>If you have further ideas, questions, or would like to contribute in any other way, please just ask me, or create issues at <a href="https://github.com/appelmar/gdalcubes_R">GitHub</a>.</p>
<hr></section><section id="exercises-ii" class="level1"><h1>Exercises (ii)</h1>
<ol type="1">
<li>Use the downsampled Landsat dataset from the first exercises and create a data cube for a spatial subarea (use the data cube view and mask below).</li>
</ol>
<pre><code>v.subarea = cube_view(extent=list(left=-6320000, right=-6220000, bottom=-600000, top=-500000, 
        t0="2014-01-01", t1="2018-12-31"), dt="P1M", dx=100, dy=100
        srs="EPSG:3857", aggregation = "median", resampling = "bilinear")
                      
L8.clear_mask = image_mask("PIXEL_QA", values=
        c(322, 386, 834, 898, 1346, 324, 388, 836, 900, 1348), 
        invert = TRUE)</code></pre>
<ol start="2" type="1">
<li><p>Calculate the normalized difference moisture index (NDMI) using the formula “(B05-B06)/(B05+B06)”. This index is used to assess vegetation water content.</p></li>
<li><p>Compute minimum, maximum, median, and mean NDMI values over time and plot the result.</p></li>
<li><p>Calculate the NDVI as in the tutorial, and apply a user defined reducer function to create a “greenest pixel” composit image, by finding the date/time of the maximum NDVI, and returning the corresponding RGB values.</p></li>
</ol></section><section id="references" class="level1">


<!-- -->


</section><div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-rgdal" class="csl-entry" role="listitem">
Bivand, Roger, Tim Keitt, and Barry Rowlingson. 2019. <em>Rgdal: Bindings for the ’Geospatial’ Data Abstraction Library</em>. <a href="https://CRAN.R-project.org/package=rgdal">https://CRAN.R-project.org/package=rgdal</a>.
</div>
<div id="ref-raster" class="csl-entry" role="listitem">
Hijmans, Robert J. 2019. <em>Raster: Geographic Data Analysis and Modeling</em>. <a href="https://CRAN.R-project.org/package=raster">https://CRAN.R-project.org/package=raster</a>.
</div>
<div id="ref-stars" class="csl-entry" role="listitem">
Pebesma, Edzer. 2019. <em>Stars: Spatiotemporal Arrays, Raster and Vector Data Cubes</em>. <a href="https://CRAN.R-project.org/package=stars">https://CRAN.R-project.org/package=stars</a>.
</div>
</div></section></div></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
          // default icon
          link.classList.add("external");
      }
    }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb70" data-shortcodes="false"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb70-1"><a href="#cb70-1"></a><span class="co">---</span></span>
<span id="cb70-2"><a href="#cb70-2"></a><span class="an">title:</span><span class="co"> "Introduction to gdalcubes using local Landsat 8 imagery"</span></span>
<span id="cb70-3"><a href="#cb70-3"></a><span class="an">author:</span><span class="co"> "Marius Appel"</span></span>
<span id="cb70-4"><a href="#cb70-4"></a><span class="an">link-citations:</span><span class="co"> true</span></span>
<span id="cb70-5"><a href="#cb70-5"></a><span class="co">---</span></span>
<span id="cb70-6"><a href="#cb70-6"></a></span>
<span id="cb70-7"><a href="#cb70-7"></a><span class="in">```{r setup, include=FALSE}</span></span>
<span id="cb70-8"><a href="#cb70-8"></a>knitr<span class="sc">::</span>opts_chunk<span class="sc">$</span><span class="fu">set</span>(<span class="at">echo =</span> <span class="cn">TRUE</span>)</span>
<span id="cb70-9"><a href="#cb70-9"></a>knitr<span class="sc">::</span>opts_chunk<span class="sc">$</span><span class="fu">set</span>(<span class="at">cache =</span> <span class="cn">TRUE</span>)</span>
<span id="cb70-10"><a href="#cb70-10"></a><span class="in">```</span></span>
<span id="cb70-11"><a href="#cb70-11"></a></span>
<span id="cb70-12"><a href="#cb70-12"></a>_This document is based on the tutorial "Processing Large Satellite Image Collections as Data Cubes with the gdalcubes R package", presented ad OpenGeoHub Summer School 2019 (see https://github.com/appelmar/opengeohub_summerschool2019)._</span>
<span id="cb70-13"><a href="#cb70-13"></a></span>
<span id="cb70-14"><a href="#cb70-14"></a></span>
<span id="cb70-15"><a href="#cb70-15"></a></span>
<span id="cb70-16"><a href="#cb70-16"></a><span class="fu"># Outline</span></span>
<span id="cb70-17"><a href="#cb70-17"></a></span>
<span id="cb70-18"><a href="#cb70-18"></a><span class="ss">- </span>Part I: Creating, Visualizing, and Exporting Data Cubes from Satellite Image Collections (45 min demonstration, 15 min practical exercises) </span>
<span id="cb70-19"><a href="#cb70-19"></a></span>
<span id="cb70-20"><a href="#cb70-20"></a></span>
<span id="cb70-21"><a href="#cb70-21"></a><span class="ss">- </span>Part II: On-the-fly Processing of Data Cubes (45 min demonstration, 15 min practical exercises) </span>
<span id="cb70-22"><a href="#cb70-22"></a></span>
<span id="cb70-23"><a href="#cb70-23"></a></span>
<span id="cb70-24"><a href="#cb70-24"></a>All the material of this tutorial is online at <span class="co">[</span><span class="ot">GitHub</span><span class="co">](https://github.com/appelmar/opengeohub_summerschool2019)</span>, including R markdown sources, rendered HTML output, and solutions to the practical exercises. However, the repository does **not** contain the data used in the tutorial due to its size.</span>
<span id="cb70-25"><a href="#cb70-25"></a></span>
<span id="cb70-26"><a href="#cb70-26"></a></span>
<span id="cb70-27"><a href="#cb70-27"></a>-----------------------------------------------------</span>
<span id="cb70-28"><a href="#cb70-28"></a></span>
<span id="cb70-29"><a href="#cb70-29"></a></span>
<span id="cb70-30"><a href="#cb70-30"></a><span class="fu"># Sample Data</span></span>
<span id="cb70-31"><a href="#cb70-31"></a></span>
<span id="cb70-32"><a href="#cb70-32"></a>Most parts of the tutorial will use a collection of 180 Landsat 8 surface reflectance images, covering a small part of the Brazilian Amazon forest. </span>
<span id="cb70-33"><a href="#cb70-33"></a>The live demonstration will use the full resolution dataset (62 gigabytes compressed; &gt; 200 gigabytes unzipped; available <span class="co">[</span><span class="ot">here</span><span class="co">](https://hs-bochum.sciebo.de/s/OAcZqaLA28VyrH8/download)</span>), whereas we will use a downsampled version of the same dataset with coarse spatial resolution (300 meter pixel size; 740 megabytes compressed; 2 gigabytes unzipped) in the practical part (available <span class="co">[</span><span class="ot">here</span><span class="co">](https://hs-bochum.sciebo.de/s/8XcKAmPfPGp2CYh/download)</span>). </span>
<span id="cb70-34"><a href="#cb70-34"></a></span>
<span id="cb70-35"><a href="#cb70-35"></a>After downloading whichever version of the dataset, make sure to unzip it. The following R code will download the low resolution version to your current working directory and unzip it.</span>
<span id="cb70-36"><a href="#cb70-36"></a></span>
<span id="cb70-37"><a href="#cb70-37"></a></span>
<span id="cb70-38"><a href="#cb70-38"></a><span class="in">```{r, include = FALSE}</span></span>
<span id="cb70-39"><a href="#cb70-39"></a>do_download <span class="ot">=</span> <span class="sc">!</span><span class="fu">dir.exists</span>(<span class="st">"L8_Amazon"</span>)</span>
<span id="cb70-40"><a href="#cb70-40"></a><span class="fu">options</span>(<span class="at">timeout =</span> <span class="fu">max</span>(<span class="dv">1800</span>, <span class="fu">getOption</span>(<span class="st">"timeout"</span>)))</span>
<span id="cb70-41"><a href="#cb70-41"></a><span class="in">```</span></span>
<span id="cb70-42"><a href="#cb70-42"></a></span>
<span id="cb70-43"><a href="#cb70-43"></a><span class="in">```{r download, eval = do_download, results='hide'}</span></span>
<span id="cb70-44"><a href="#cb70-44"></a><span class="fu">download.file</span>(<span class="st">"https://hs-bochum.sciebo.de/s/8XcKAmPfPGp2CYh/download"</span>, </span>
<span id="cb70-45"><a href="#cb70-45"></a>              <span class="at">destfile =</span> <span class="st">"L8_Amazon.zip"</span>, <span class="at">mode=</span><span class="st">"wb"</span>)</span>
<span id="cb70-46"><a href="#cb70-46"></a><span class="fu">unzip</span>(<span class="st">"L8_Amazon.zip"</span>, <span class="at">exdir =</span> <span class="st">"L8_Amazon"</span>)</span>
<span id="cb70-47"><a href="#cb70-47"></a><span class="in">```</span></span>
<span id="cb70-48"><a href="#cb70-48"></a></span>
<span id="cb70-49"><a href="#cb70-49"></a></span>
<span id="cb70-50"><a href="#cb70-50"></a>------------------------------------------------------</span>
<span id="cb70-51"><a href="#cb70-51"></a></span>
<span id="cb70-52"><a href="#cb70-52"></a></span>
<span id="cb70-53"><a href="#cb70-53"></a><span class="fu"># Part I: Creating, Visualizing, and Exporting Data Cubes from Satellite Image Collections</span></span>
<span id="cb70-54"><a href="#cb70-54"></a></span>
<span id="cb70-55"><a href="#cb70-55"></a></span>
<span id="cb70-56"><a href="#cb70-56"></a></span>
<span id="cb70-57"><a href="#cb70-57"></a></span>
<span id="cb70-58"><a href="#cb70-58"></a><span class="fu">## The Problem</span></span>
<span id="cb70-59"><a href="#cb70-59"></a></span>
<span id="cb70-60"><a href="#cb70-60"></a>Raw satellite imagery is mostly distributed as collection of files, whether on download portals of space agencies, or in cloud computing environments (Amazon Web Services, Google Cloud, ...). If we want to analyze more than a single image, or even images from multiple satellites, we quickly run into the following challenges: </span>
<span id="cb70-61"><a href="#cb70-61"></a></span>
<span id="cb70-62"><a href="#cb70-62"></a><span class="ss">- </span>spectral bands at different spatial resolutions </span>
<span id="cb70-63"><a href="#cb70-63"></a><span class="ss">- </span>spatially overlapping images</span>
<span id="cb70-64"><a href="#cb70-64"></a><span class="ss">- </span>irregular time series for pixels from different tiles (or in overlapping areas)</span>
<span id="cb70-65"><a href="#cb70-65"></a><span class="ss">- </span>different spatial reference systems of images</span>
<span id="cb70-66"><a href="#cb70-66"></a><span class="ss">- </span>different data formats and structures</span>
<span id="cb70-67"><a href="#cb70-67"></a></span>
<span id="cb70-68"><a href="#cb70-68"></a></span>
<span id="cb70-69"><a href="#cb70-69"></a>To do time series analysis, process larger areas, and / or combine datasets from different sensors / satellites, we first must restructure our data, e.g. as a data cube with a single spatial reference system, regular pixel sizes, both in time and in space.</span>
<span id="cb70-70"><a href="#cb70-70"></a></span>
<span id="cb70-71"><a href="#cb70-71"></a></span>
<span id="cb70-72"><a href="#cb70-72"></a><span class="al">![](cube.png)</span></span>
<span id="cb70-73"><a href="#cb70-73"></a></span>
<span id="cb70-74"><a href="#cb70-74"></a></span>
<span id="cb70-75"><a href="#cb70-75"></a>Notice that what we call *cube* is actually not really a cube. It has (up to) four dimensions, and the lengths of the dimensions may be different.</span>
<span id="cb70-76"><a href="#cb70-76"></a>Therefore, four dimensional regular raster data cubes also cover simple time series, multiband time series, grayscale images, multispectral images, and time-series of images.</span>
<span id="cb70-77"><a href="#cb70-77"></a></span>
<span id="cb70-78"><a href="#cb70-78"></a></span>
<span id="cb70-79"><a href="#cb70-79"></a></span>
<span id="cb70-80"><a href="#cb70-80"></a><span class="fu">## Existing Tools (with a focus on R)</span></span>
<span id="cb70-81"><a href="#cb70-81"></a></span>
<span id="cb70-82"><a href="#cb70-82"></a><span class="co">[</span><span class="ot">GDAL</span><span class="co">](https://gdal.org)</span>, the Geospatial Data Abstraction Library is a software library reading and writing all relevant raster (and vector) data formats, and providing functions to warp (reproject, rescale, resample, and crop) multiband raster images. It has a three dimensional (space, bands) raster data model and solves some of the problems (data formats, image warping). However, it does *not* know about the organization of data products, and time. GDAL is written in C / C++ but the <span class="in">`rgdal`</span>package <span class="co">[</span><span class="ot">@rgdal</span><span class="co">]</span> provides an easy to use interface in R.</span>
<span id="cb70-83"><a href="#cb70-83"></a></span>
<span id="cb70-84"><a href="#cb70-84"></a>There are further R packages to process satellite imagery:</span>
<span id="cb70-85"><a href="#cb70-85"></a></span>
<span id="cb70-86"><a href="#cb70-86"></a><span class="in">`raster`</span> <span class="co">[</span><span class="ot">@raster</span><span class="co">]</span></span>
<span id="cb70-87"><a href="#cb70-87"></a></span>
<span id="cb70-88"><a href="#cb70-88"></a><span class="ss">- </span>well established, stable, reliable</span>
<span id="cb70-89"><a href="#cb70-89"></a><span class="ss">- </span>three-dimensional only, no multispectral AND multitemporal stacks</span>
<span id="cb70-90"><a href="#cb70-90"></a><span class="ss">- </span>chaining operations on rasters (stacks / bricks) always writes intermediate results to disk</span>
<span id="cb70-91"><a href="#cb70-91"></a><span class="ss">- </span>works on full resolution data, requires additional steps e.g. to try out things on lower resolution</span>
<span id="cb70-92"><a href="#cb70-92"></a><span class="ss">- </span>currently being rewritten (see https://github.com/rspatial/terra)</span>
<span id="cb70-93"><a href="#cb70-93"></a></span>
<span id="cb70-94"><a href="#cb70-94"></a></span>
<span id="cb70-95"><a href="#cb70-95"></a><span class="in">`stars`</span> <span class="co">[</span><span class="ot">@stars</span><span class="co">]</span> (see parallel session) </span>
<span id="cb70-96"><a href="#cb70-96"></a></span>
<span id="cb70-97"><a href="#cb70-97"></a><span class="ss">- </span>arbitrary dimensions</span>
<span id="cb70-98"><a href="#cb70-98"></a><span class="ss">- </span>assumes a data cube as input (does not do spatial mosaicing, temporal aggregation)</span>
<span id="cb70-99"><a href="#cb70-99"></a><span class="ss">- </span>has vector data cubes</span>
<span id="cb70-100"><a href="#cb70-100"></a><span class="ss">- </span>lazy evaluation approach, compute only the pixels you see.</span>
<span id="cb70-101"><a href="#cb70-101"></a></span>
<span id="cb70-102"><a href="#cb70-102"></a></span>
<span id="cb70-103"><a href="#cb70-103"></a></span>
<span id="cb70-104"><a href="#cb70-104"></a></span>
<span id="cb70-105"><a href="#cb70-105"></a></span>
<span id="cb70-106"><a href="#cb70-106"></a><span class="fu">## First Steps with gdalcubes</span></span>
<span id="cb70-107"><a href="#cb70-107"></a></span>
<span id="cb70-108"><a href="#cb70-108"></a>gdalcubes is a relatively new R package that mostly wraps functions written in C++. It uses GDAL to read, write, and warp images, but understands date/time and how complex satellite image data products are organized. To get started, please install the gdalcubes package from CRAN with:</span>
<span id="cb70-109"><a href="#cb70-109"></a></span>
<span id="cb70-110"><a href="#cb70-110"></a><span class="in">```{r install, eval = FALSE}</span></span>
<span id="cb70-111"><a href="#cb70-111"></a><span class="fu">install.packages</span>(<span class="st">"gdalcubes"</span>)</span>
<span id="cb70-112"><a href="#cb70-112"></a><span class="in">```</span></span>
<span id="cb70-113"><a href="#cb70-113"></a></span>
<span id="cb70-114"><a href="#cb70-114"></a>We can load the package and make sure that all computations later in this tutorial use up to 8 parallel processes with:</span>
<span id="cb70-115"><a href="#cb70-115"></a></span>
<span id="cb70-116"><a href="#cb70-116"></a><span class="in">```{r setup_gdalcubes}</span></span>
<span id="cb70-117"><a href="#cb70-117"></a><span class="fu">library</span>(gdalcubes)</span>
<span id="cb70-118"><a href="#cb70-118"></a><span class="fu">gdalcubes_options</span>(<span class="at">parallel =</span> <span class="dv">8</span>)</span>
<span id="cb70-119"><a href="#cb70-119"></a><span class="in">```</span></span>
<span id="cb70-120"><a href="#cb70-120"></a></span>
<span id="cb70-121"><a href="#cb70-121"></a>Please notice that this tutorial needs package version &gt;= 0.6.0, which you can check by running:</span>
<span id="cb70-122"><a href="#cb70-122"></a></span>
<span id="cb70-123"><a href="#cb70-123"></a><span class="in">```{r pkgversion}</span></span>
<span id="cb70-124"><a href="#cb70-124"></a><span class="fu">packageVersion</span>(<span class="st">"gdalcubes"</span>)</span>
<span id="cb70-125"><a href="#cb70-125"></a><span class="in">```</span></span>
<span id="cb70-126"><a href="#cb70-126"></a></span>
<span id="cb70-127"><a href="#cb70-127"></a></span>
<span id="cb70-128"><a href="#cb70-128"></a></span>
<span id="cb70-129"><a href="#cb70-129"></a><span class="fu">## Creating an Image Collection</span></span>
<span id="cb70-130"><a href="#cb70-130"></a></span>
<span id="cb70-131"><a href="#cb70-131"></a>To analyze our sample dataset, we must first tell gdalcubes, which files belong to the image collection, and where to find them.</span>
<span id="cb70-132"><a href="#cb70-132"></a></span>
<span id="cb70-133"><a href="#cb70-133"></a>At first, we simply list (recursively) all GeoTIFF files in the directory with the Landsat 8 images:</span>
<span id="cb70-134"><a href="#cb70-134"></a></span>
<span id="cb70-135"><a href="#cb70-135"></a><span class="in">```{r L8files}</span></span>
<span id="cb70-136"><a href="#cb70-136"></a>L8.files <span class="ot">=</span> <span class="fu">list.files</span>(<span class="st">"L8_Amazon"</span>, <span class="at">pattern =</span> <span class="st">".tif"</span>, <span class="at">recursive =</span> <span class="cn">TRUE</span>, <span class="at">full.names =</span> <span class="cn">TRUE</span>) </span>
<span id="cb70-137"><a href="#cb70-137"></a><span class="fu">head</span>(L8.files, <span class="dv">15</span>)</span>
<span id="cb70-138"><a href="#cb70-138"></a><span class="fu">sum</span>(<span class="fu">file.size</span>(L8.files)) <span class="sc">/</span> <span class="dv">1000</span><span class="sc">^</span><span class="dv">3</span> <span class="co"># gigabytes</span></span>
<span id="cb70-139"><a href="#cb70-139"></a><span class="in">```</span></span>
<span id="cb70-140"><a href="#cb70-140"></a></span>
<span id="cb70-141"><a href="#cb70-141"></a>We see that every image is represented by a directory, with individual files for spectral bands. We can then add all images to an image collection with:</span>
<span id="cb70-142"><a href="#cb70-142"></a></span>
<span id="cb70-143"><a href="#cb70-143"></a><span class="in">```{r L8col}</span></span>
<span id="cb70-144"><a href="#cb70-144"></a>L8.col <span class="ot">=</span> <span class="fu">create_image_collection</span>(L8.files, <span class="at">format =</span> <span class="st">"L8_SR"</span>, <span class="at">out_file =</span> <span class="st">"L8.db"</span>)</span>
<span id="cb70-145"><a href="#cb70-145"></a><span class="co"># L8.col = image_collection("L8.db") </span></span>
<span id="cb70-146"><a href="#cb70-146"></a>L8.col</span>
<span id="cb70-147"><a href="#cb70-147"></a><span class="in">```</span></span>
<span id="cb70-148"><a href="#cb70-148"></a></span>
<span id="cb70-149"><a href="#cb70-149"></a>This opens all provided files once, reads some relevant metadata (spatial extent, reference system, recording date/time, and how the file relates to the spectral bands of the data product). The <span class="in">`format`</span> argument describes, how this information can be extracted. The gdalcubes package comes with a set of predefined **image collection formats** for particular data products. We can list available formats with:</span>
<span id="cb70-150"><a href="#cb70-150"></a></span>
<span id="cb70-151"><a href="#cb70-151"></a><span class="in">```{r colformats}</span></span>
<span id="cb70-152"><a href="#cb70-152"></a><span class="fu">collection_formats</span>()</span>
<span id="cb70-153"><a href="#cb70-153"></a><span class="in">```</span></span>
<span id="cb70-154"><a href="#cb70-154"></a></span>
<span id="cb70-155"><a href="#cb70-155"></a>The number of available formats is still rather limited, but continues to grow and is extensible (using <span class="in">`add_collection_format()`</span>). In fact, a collection format is a single JSON (JavaScript Object Notation) file, describing some rules how to extract e.g. date/time, and bands from filenames (examples at https://github.com/appelmar/gdalcubes_formats). Writing collection formats for your own non-standard datasets is not too difficult and documented <span class="co">[</span><span class="ot">here</span><span class="co">](https://gdalcubes.github.io/docs/collection_formats.html)</span>.</span>
<span id="cb70-156"><a href="#cb70-156"></a></span>
<span id="cb70-157"><a href="#cb70-157"></a>In our example, we used the predefined format <span class="in">`"L8_SR"`</span> for Landsat 8 surface reflectance data as downloaded from the <span class="co">[</span><span class="ot">USGS portal</span><span class="co">](https://espa.cr.usgs.gov)</span>.</span>
<span id="cb70-158"><a href="#cb70-158"></a></span>
<span id="cb70-159"><a href="#cb70-159"></a>The creation of image collections is typically done only once. We can add images to an existing collection with  <span class="in">`add_images()`</span>. </span>
<span id="cb70-160"><a href="#cb70-160"></a></span>
<span id="cb70-161"><a href="#cb70-161"></a>We can extract the spatiotemporal extent of the collection with:</span>
<span id="cb70-162"><a href="#cb70-162"></a></span>
<span id="cb70-163"><a href="#cb70-163"></a><span class="in">```{r L8extent}</span></span>
<span id="cb70-164"><a href="#cb70-164"></a><span class="fu">extent</span>(L8.col, <span class="at">srs=</span><span class="st">"EPSG:4326"</span>)</span>
<span id="cb70-165"><a href="#cb70-165"></a><span class="in">```</span></span>
<span id="cb70-166"><a href="#cb70-166"></a></span>
<span id="cb70-167"><a href="#cb70-167"></a></span>
<span id="cb70-168"><a href="#cb70-168"></a></span>
<span id="cb70-169"><a href="#cb70-169"></a></span>
<span id="cb70-170"><a href="#cb70-170"></a><span class="fu">## Defining a *Data Cube View*: A Virtual Data Cube</span></span>
<span id="cb70-171"><a href="#cb70-171"></a></span>
<span id="cb70-172"><a href="#cb70-172"></a>We can define a target data cube by its geometry, i.e., the spatiotemporal extent, the spatial reference system, the spatial size, and the temporal duration of cells. We call this a *data cube view*, i.e. the geometry of a cube without connecting it to any data.</span>
<span id="cb70-173"><a href="#cb70-173"></a>To create a data cube view, we can use the <span class="in">`cube_view()`</span> function:</span>
<span id="cb70-174"><a href="#cb70-174"></a></span>
<span id="cb70-175"><a href="#cb70-175"></a></span>
<span id="cb70-176"><a href="#cb70-176"></a></span>
<span id="cb70-177"><a href="#cb70-177"></a></span>
<span id="cb70-178"><a href="#cb70-178"></a><span class="in">```{r L8cubeview}</span></span>
<span id="cb70-179"><a href="#cb70-179"></a><span class="co"># Coarse resolution overview</span></span>
<span id="cb70-180"><a href="#cb70-180"></a>v.overview<span class="fl">.500</span>m <span class="ot">=</span> <span class="fu">cube_view</span>(<span class="at">srs=</span><span class="st">"EPSG:3857"</span>, <span class="at">extent=</span>L8.col, <span class="at">dx=</span><span class="dv">500</span>, <span class="at">dy=</span><span class="dv">500</span>, <span class="at">dt =</span> <span class="st">"P1Y"</span>, <span class="at">resampling=</span><span class="st">"average"</span>, <span class="at">aggregation=</span><span class="st">"median"</span>)</span>
<span id="cb70-181"><a href="#cb70-181"></a>v.overview<span class="fl">.500</span>m</span>
<span id="cb70-182"><a href="#cb70-182"></a></span>
<span id="cb70-183"><a href="#cb70-183"></a>v.subarea<span class="fl">.60</span>m <span class="ot">=</span> <span class="fu">cube_view</span>(<span class="at">extent=</span><span class="fu">list</span>(<span class="at">left=</span><span class="sc">-</span><span class="dv">6180000</span>, <span class="at">right=</span><span class="sc">-</span><span class="dv">6080000</span>, <span class="at">bottom=</span><span class="sc">-</span><span class="dv">550000</span>, <span class="at">top=</span><span class="sc">-</span><span class="dv">450000</span>, </span>
<span id="cb70-184"><a href="#cb70-184"></a>   <span class="at">t0=</span><span class="st">"2014-01-01"</span>, <span class="at">t1=</span><span class="st">"2018-12-31"</span>), <span class="at">dt=</span><span class="st">"P1Y"</span>, <span class="at">dx=</span><span class="dv">60</span>, <span class="at">dy=</span><span class="dv">60</span>, <span class="at">srs=</span><span class="st">"EPSG:3857"</span>, </span>
<span id="cb70-185"><a href="#cb70-185"></a>   <span class="at">aggregation =</span> <span class="st">"median"</span>, <span class="at">resampling =</span> <span class="st">"average"</span>)</span>
<span id="cb70-186"><a href="#cb70-186"></a>v.subarea<span class="fl">.60</span>m</span>
<span id="cb70-187"><a href="#cb70-187"></a></span>
<span id="cb70-188"><a href="#cb70-188"></a></span>
<span id="cb70-189"><a href="#cb70-189"></a>v.subarea<span class="fl">.60</span>m.daily <span class="ot">=</span>  <span class="fu">cube_view</span>(<span class="at">view =</span> v.subarea<span class="fl">.60</span>m, <span class="at">dt=</span><span class="st">"P1D"</span>) </span>
<span id="cb70-190"><a href="#cb70-190"></a>v.subarea<span class="fl">.60</span>m.daily</span>
<span id="cb70-191"><a href="#cb70-191"></a><span class="in">```</span></span>
<span id="cb70-192"><a href="#cb70-192"></a></span>
<span id="cb70-193"><a href="#cb70-193"></a>Notice that the data cube view does not contain any information on bands, because it is independent from particular data products. </span>
<span id="cb70-194"><a href="#cb70-194"></a></span>
<span id="cb70-195"><a href="#cb70-195"></a></span>
<span id="cb70-196"><a href="#cb70-196"></a><span class="fu">## Creating Data Cubes</span></span>
<span id="cb70-197"><a href="#cb70-197"></a></span>
<span id="cb70-198"><a href="#cb70-198"></a>Having defined an *image collection*, and a *data cube view*, a data cube is simply the combination of the two.</span>
<span id="cb70-199"><a href="#cb70-199"></a>We can create a data cube with the <span class="in">`raster_cube()`</span> function:</span>
<span id="cb70-200"><a href="#cb70-200"></a></span>
<span id="cb70-201"><a href="#cb70-201"></a><span class="in">```{r L8datacube}</span></span>
<span id="cb70-202"><a href="#cb70-202"></a>L8.cube.overview <span class="ot">=</span> <span class="fu">raster_cube</span>(L8.col, v.overview<span class="fl">.500</span>m)</span>
<span id="cb70-203"><a href="#cb70-203"></a>L8.cube.overview</span>
<span id="cb70-204"><a href="#cb70-204"></a></span>
<span id="cb70-205"><a href="#cb70-205"></a>L8.cube.subarea <span class="ot">=</span> <span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m)</span>
<span id="cb70-206"><a href="#cb70-206"></a>L8.cube.subarea</span>
<span id="cb70-207"><a href="#cb70-207"></a></span>
<span id="cb70-208"><a href="#cb70-208"></a>L8.cube.subarea.daily <span class="ot">=</span> <span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m.daily)</span>
<span id="cb70-209"><a href="#cb70-209"></a>L8.cube.subarea.daily</span>
<span id="cb70-210"><a href="#cb70-210"></a><span class="in">```</span></span>
<span id="cb70-211"><a href="#cb70-211"></a></span>
<span id="cb70-212"><a href="#cb70-212"></a></span>
<span id="cb70-213"><a href="#cb70-213"></a>This is very cheap, simply returning *proxy* objects, but not reading any image data. The package delays the computational intensive parts as much as possible (e.g., until users call <span class="in">`plot()`</span>). The returned object knows about the bands of the data product. We can use <span class="in">`select_bands()`</span> to get only the bands we are interested in:</span>
<span id="cb70-214"><a href="#cb70-214"></a></span>
<span id="cb70-215"><a href="#cb70-215"></a><span class="in">```{r L8rgb}</span></span>
<span id="cb70-216"><a href="#cb70-216"></a>L8.cube.overview.rgb <span class="ot">=</span> <span class="fu">select_bands</span>(L8.cube.overview, <span class="fu">c</span>(<span class="st">"B02"</span>, <span class="st">"B03"</span>, <span class="st">"B04"</span>))</span>
<span id="cb70-217"><a href="#cb70-217"></a>L8.cube.overview.rgb</span>
<span id="cb70-218"><a href="#cb70-218"></a><span class="in">```</span></span>
<span id="cb70-219"><a href="#cb70-219"></a></span>
<span id="cb70-220"><a href="#cb70-220"></a></span>
<span id="cb70-221"><a href="#cb70-221"></a>There are some utility functions on data cubes, including:</span>
<span id="cb70-222"><a href="#cb70-222"></a></span>
<span id="cb70-223"><a href="#cb70-223"></a><span class="in">```{r datacubefun}</span></span>
<span id="cb70-224"><a href="#cb70-224"></a><span class="fu">names</span>(L8.cube.overview.rgb)</span>
<span id="cb70-225"><a href="#cb70-225"></a><span class="fu">srs</span>(L8.cube.overview.rgb)</span>
<span id="cb70-226"><a href="#cb70-226"></a><span class="fu">bands</span>(L8.cube.overview.rgb)</span>
<span id="cb70-227"><a href="#cb70-227"></a><span class="in">```</span></span>
<span id="cb70-228"><a href="#cb70-228"></a></span>
<span id="cb70-229"><a href="#cb70-229"></a></span>
<span id="cb70-230"><a href="#cb70-230"></a></span>
<span id="cb70-231"><a href="#cb70-231"></a></span>
<span id="cb70-232"><a href="#cb70-232"></a><span class="fu">## Plotting Data Cubes</span></span>
<span id="cb70-233"><a href="#cb70-233"></a></span>
<span id="cb70-234"><a href="#cb70-234"></a>The plot function can be used to visualize data cubes. Calling <span class="in">`plot()`</span> will start reading and processing the data:</span>
<span id="cb70-235"><a href="#cb70-235"></a></span>
<span id="cb70-236"><a href="#cb70-236"></a>For a simple RGB plot, we use the <span class="in">`rgb`</span> argument to specify which bands correspond to the red, green, and blue channels, and specify the black and white points of the channels (to control contrast and brightness) in <span class="in">`zlim`</span>.</span>
<span id="cb70-237"><a href="#cb70-237"></a></span>
<span id="cb70-238"><a href="#cb70-238"></a></span>
<span id="cb70-239"><a href="#cb70-239"></a><span class="in">```{r L8plot1}</span></span>
<span id="cb70-240"><a href="#cb70-240"></a><span class="fu">plot</span>(L8.cube.overview.rgb, <span class="at">rgb=</span><span class="dv">3</span><span class="sc">:</span><span class="dv">1</span>, <span class="at">zlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1500</span>))</span>
<span id="cb70-241"><a href="#cb70-241"></a><span class="fu">plot</span>(<span class="fu">select_bands</span>(L8.cube.subarea, <span class="fu">c</span>(<span class="st">"B02"</span>, <span class="st">"B03"</span>, <span class="st">"B04"</span>)), <span class="at">rgb=</span><span class="dv">3</span><span class="sc">:</span><span class="dv">1</span>, <span class="at">zlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1500</span>))</span>
<span id="cb70-242"><a href="#cb70-242"></a><span class="in">```</span></span>
<span id="cb70-243"><a href="#cb70-243"></a></span>
<span id="cb70-244"><a href="#cb70-244"></a></span>
<span id="cb70-245"><a href="#cb70-245"></a>Notice that we can also plot bands individually, creating a two-dimensional plot layout of bands and time. Using <span class="in">`key.pos = 1`</span>, and <span class="in">`col= viridis::viridis`</span>, we plot a legend at the bottom of the plot, and use the viridis color scales (this requires the viridis package). </span>
<span id="cb70-246"><a href="#cb70-246"></a></span>
<span id="cb70-247"><a href="#cb70-247"></a></span>
<span id="cb70-248"><a href="#cb70-248"></a><span class="in">```{r L8plot2, message=FALSE}</span></span>
<span id="cb70-249"><a href="#cb70-249"></a><span class="fu">plot</span>(L8.cube.overview.rgb, <span class="at">zlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1500</span>), <span class="at">key.pos=</span><span class="dv">1</span>, <span class="at">col=</span>viridis<span class="sc">::</span>viridis, <span class="at">t=</span><span class="dv">2</span><span class="sc">:</span><span class="dv">5</span>) </span>
<span id="cb70-250"><a href="#cb70-250"></a><span class="fu">plot</span>(<span class="fu">select_bands</span>(<span class="fu">raster_cube</span>(L8.col,<span class="at">view =</span> v.subarea<span class="fl">.60</span>m), <span class="fu">c</span>(<span class="st">"B05"</span>)),<span class="at">col=</span>viridis<span class="sc">::</span>viridis,  <span class="at">zlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">6000</span>), <span class="at">key.pos=</span><span class="dv">1</span>)</span>
<span id="cb70-251"><a href="#cb70-251"></a><span class="in">```</span></span>
<span id="cb70-252"><a href="#cb70-252"></a></span>
<span id="cb70-253"><a href="#cb70-253"></a>Plotting an identical data cube twice, with different visualization arguments <span class="in">`zlim`</span>, <span class="in">`col`</span>, and others will not need to reprocess the data cube again. <span class="in">`plot()`</span> internally writes netCDF files to a temporary directory and remembers that a specific cube is already available.</span>
<span id="cb70-254"><a href="#cb70-254"></a></span>
<span id="cb70-255"><a href="#cb70-255"></a>The <span class="in">`plot()`</span> function also considers different types of data cubes. For example, if the number of cells in x and y direction equals one, we get a simple time series plot, as we will see later in this tutorial.</span>
<span id="cb70-256"><a href="#cb70-256"></a></span>
<span id="cb70-257"><a href="#cb70-257"></a></span>
<span id="cb70-258"><a href="#cb70-258"></a><span class="fu">### Animations</span></span>
<span id="cb70-259"><a href="#cb70-259"></a></span>
<span id="cb70-260"><a href="#cb70-260"></a>The data cube representation makes it straightforward to create animations, by plotting time slices of the cube individually, and use these plots as animation frames:</span>
<span id="cb70-261"><a href="#cb70-261"></a></span>
<span id="cb70-262"><a href="#cb70-262"></a><span class="in">```{r L8anim1}</span></span>
<span id="cb70-263"><a href="#cb70-263"></a><span class="fu">animate</span>(<span class="fu">select_bands</span>(<span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m), <span class="fu">c</span>(<span class="st">"B02"</span>,<span class="st">"B03"</span>,<span class="st">"B04"</span>)), <span class="at">rgb=</span><span class="dv">3</span><span class="sc">:</span><span class="dv">1</span>, <span class="at">zlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1500</span>))</span>
<span id="cb70-264"><a href="#cb70-264"></a><span class="in">```</span></span>
<span id="cb70-265"><a href="#cb70-265"></a></span>
<span id="cb70-266"><a href="#cb70-266"></a></span>
<span id="cb70-267"><a href="#cb70-267"></a></span>
<span id="cb70-268"><a href="#cb70-268"></a><span class="fu">## Exporting Data Cubes to Disk</span></span>
<span id="cb70-269"><a href="#cb70-269"></a></span>
<span id="cb70-270"><a href="#cb70-270"></a>Sometimes we want to process data cubes further, e.g. with external software. We can export data cubes either as single netCDF files, or as a collection of GeoTIFF files, where each time-slice of a cube will be stored as one (multiband) file.</span>
<span id="cb70-271"><a href="#cb70-271"></a></span>
<span id="cb70-272"><a href="#cb70-272"></a>Both, netCDF and GeoTIFF export support *compression*, and *packing* (converting double precision numeric values to smaller integer types by applying an offset and scale) to reduce the file size if needed (see documentation at <span class="in">`?write_ncdf`</span>, and <span class="in">`?write_tif`</span>).</span>
<span id="cb70-273"><a href="#cb70-273"></a></span>
<span id="cb70-274"><a href="#cb70-274"></a></span>
<span id="cb70-275"><a href="#cb70-275"></a><span class="in">```{r L8export}</span></span>
<span id="cb70-276"><a href="#cb70-276"></a><span class="fu">gdalcubes_options</span>(<span class="at">ncdf_compression_level =</span> <span class="dv">1</span>)</span>
<span id="cb70-277"><a href="#cb70-277"></a><span class="fu">write_ncdf</span>(L8.cube.overview.rgb, <span class="fu">file.path</span>(<span class="st">"~/Desktop"</span>, <span class="fu">basename</span>(<span class="fu">tempfile</span>(<span class="at">fileext =</span> <span class="st">".nc"</span>))))</span>
<span id="cb70-278"><a href="#cb70-278"></a><span class="fu">gdalcubes_options</span>(<span class="at">ncdf_compression_level =</span> <span class="dv">0</span>)</span>
<span id="cb70-279"><a href="#cb70-279"></a><span class="in">```</span></span>
<span id="cb70-280"><a href="#cb70-280"></a></span>
<span id="cb70-281"><a href="#cb70-281"></a><span class="in">`write_tif()`</span> and <span class="in">`write_ncdf()`</span> both return the path(s) to created file(s) as a character vector.</span>
<span id="cb70-282"><a href="#cb70-282"></a></span>
<span id="cb70-283"><a href="#cb70-283"></a></span>
<span id="cb70-284"><a href="#cb70-284"></a><span class="fu">## Interfacing Existing R Packages</span></span>
<span id="cb70-285"><a href="#cb70-285"></a></span>
<span id="cb70-286"><a href="#cb70-286"></a></span>
<span id="cb70-287"><a href="#cb70-287"></a>The package comes with a function <span class="in">`as_stars()`</span> to convert data cubes to <span class="in">`stars`</span> objects <span class="co">[</span><span class="ot">@stars</span><span class="co">]</span>, data cubes supporting any number of dimensions, and even vector data cubes.</span>
<span id="cb70-288"><a href="#cb70-288"></a></span>
<span id="cb70-289"><a href="#cb70-289"></a><span class="in">```{r L8stars}</span></span>
<span id="cb70-290"><a href="#cb70-290"></a><span class="fu">library</span>(stars)</span>
<span id="cb70-291"><a href="#cb70-291"></a>x <span class="ot">=</span> <span class="fu">st_as_stars</span>(</span>
<span id="cb70-292"><a href="#cb70-292"></a>    <span class="fu">select_bands</span>(</span>
<span id="cb70-293"><a href="#cb70-293"></a>      <span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m), <span class="st">"B05"</span>))</span>
<span id="cb70-294"><a href="#cb70-294"></a>x</span>
<span id="cb70-295"><a href="#cb70-295"></a><span class="fu">plot</span>(x)</span>
<span id="cb70-296"><a href="#cb70-296"></a><span class="in">```</span></span>
<span id="cb70-297"><a href="#cb70-297"></a></span>
<span id="cb70-298"><a href="#cb70-298"></a>The resulting object considers bands as array attributes that can be converted to a new dimension e.g. with <span class="in">`stars::st_redimension()`</span>.</span>
<span id="cb70-299"><a href="#cb70-299"></a></span>
<span id="cb70-300"><a href="#cb70-300"></a></span>
<span id="cb70-301"><a href="#cb70-301"></a></span>
<span id="cb70-302"><a href="#cb70-302"></a>If the raster cube has only a single band, or a single time slice, it is also possible to convert it to a raster (stack), by using <span class="in">`write_tif()`</span>:</span>
<span id="cb70-303"><a href="#cb70-303"></a></span>
<span id="cb70-304"><a href="#cb70-304"></a></span>
<span id="cb70-305"><a href="#cb70-305"></a><span class="in">```{r L8raster}</span></span>
<span id="cb70-306"><a href="#cb70-306"></a>x <span class="ot">=</span> raster<span class="sc">::</span><span class="fu">stack</span>(</span>
<span id="cb70-307"><a href="#cb70-307"></a>  <span class="fu">write_tif</span>(</span>
<span id="cb70-308"><a href="#cb70-308"></a>    <span class="fu">select_bands</span>(</span>
<span id="cb70-309"><a href="#cb70-309"></a>      <span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m), <span class="st">"B05"</span>)))</span>
<span id="cb70-310"><a href="#cb70-310"></a>x</span>
<span id="cb70-311"><a href="#cb70-311"></a><span class="in">```</span></span>
<span id="cb70-312"><a href="#cb70-312"></a></span>
<span id="cb70-313"><a href="#cb70-313"></a></span>
<span id="cb70-314"><a href="#cb70-314"></a></span>
<span id="cb70-315"><a href="#cb70-315"></a><span class="fu">## More Data Cube Creation Options</span></span>
<span id="cb70-316"><a href="#cb70-316"></a></span>
<span id="cb70-317"><a href="#cb70-317"></a>The <span class="in">`raster_cube()`</span> function receives two further optional arguments.</span>
<span id="cb70-318"><a href="#cb70-318"></a></span>
<span id="cb70-319"><a href="#cb70-319"></a>The <span class="in">`mask`</span> argument can be used to apply image masks during construction of the data cube if the data products includes a mask band (e.g. for clouds, cloud shadows, or general quality flags). To define a mask, we typically call the <span class="in">`image_mask()`</span> function. This function expects the name of the mask band as its first <span class="in">`band`</span> argument. Additionally, we can either pass a vector of values that are masked (all bands set to NA if the specified <span class="in">`band`</span> has one of the provided values) as the <span class="in">`values`</span> argument, or give a range of mask values by passing minimum and maximum values as <span class="in">`min`</span> and <span class="in">`max`</span> arguments. Masks can be inverted by setting <span class="in">`invert = TRUE`</span>. For bit field masks, it is possible to extract specific bits (applying a logical AND) of the band values, before comparing them to the values or range of the mask.</span>
<span id="cb70-320"><a href="#cb70-320"></a></span>
<span id="cb70-321"><a href="#cb70-321"></a>The example below will mask all pixels with a <span class="in">`"PIXEL_QA"`</span> value different from the provided values (taken from the Landsat 8 handbook). </span>
<span id="cb70-322"><a href="#cb70-322"></a></span>
<span id="cb70-323"><a href="#cb70-323"></a><span class="in">```{r L8masking}</span></span>
<span id="cb70-324"><a href="#cb70-324"></a>L8.clear_mask <span class="ot">=</span> <span class="fu">image_mask</span>(<span class="st">"PIXEL_QA"</span>, <span class="at">values=</span><span class="fu">c</span>(<span class="dv">322</span>, <span class="dv">386</span>, <span class="dv">834</span>, <span class="dv">898</span>, <span class="dv">1346</span>, <span class="dv">324</span>, <span class="dv">388</span>, <span class="dv">836</span>, <span class="dv">900</span>, <span class="dv">1348</span>), <span class="at">invert =</span> <span class="cn">TRUE</span>)</span>
<span id="cb70-325"><a href="#cb70-325"></a>x <span class="ot">=</span> <span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m, <span class="at">mask=</span>L8.clear_mask) </span>
<span id="cb70-326"><a href="#cb70-326"></a>x <span class="ot">=</span> <span class="fu">select_bands</span>(x, <span class="fu">c</span>(<span class="st">"B02"</span>,<span class="st">"B03"</span>,<span class="st">"B04"</span>))</span>
<span id="cb70-327"><a href="#cb70-327"></a><span class="fu">animate</span>(x, <span class="at">rgb=</span><span class="dv">3</span><span class="sc">:</span><span class="dv">1</span>, <span class="at">zlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1500</span>))</span>
<span id="cb70-328"><a href="#cb70-328"></a><span class="in">```</span></span>
<span id="cb70-329"><a href="#cb70-329"></a></span>
<span id="cb70-330"><a href="#cb70-330"></a></span>
<span id="cb70-331"><a href="#cb70-331"></a>The <span class="in">`chunking`</span> argument defines the size of data cube chunks as a vector with three integer values for the number of pixels in time, y, and x directions respectively.  Chunks are read completely into main memory, i.e., smaller chunks will generally reduce the main memory consumption. The size of chunks also has an effect on parallelization. Internally, chunks of the target data cube are read and processed independently, potentially by multiple threads. However, the effect of the chunk size on the performance is much more complex and depends on how we process the data (e.g., time series vs. time slices oriented), and how the data is stored. Some data formats e.g. do not allow efficient range selection reads whereas others do. </span>
<span id="cb70-332"><a href="#cb70-332"></a></span>
<span id="cb70-333"><a href="#cb70-333"></a></span>
<span id="cb70-334"><a href="#cb70-334"></a></span>
<span id="cb70-335"><a href="#cb70-335"></a>---------------------------------</span>
<span id="cb70-336"><a href="#cb70-336"></a></span>
<span id="cb70-337"><a href="#cb70-337"></a></span>
<span id="cb70-338"><a href="#cb70-338"></a></span>
<span id="cb70-339"><a href="#cb70-339"></a><span class="fu"># Exercises (i)</span></span>
<span id="cb70-340"><a href="#cb70-340"></a></span>
<span id="cb70-341"><a href="#cb70-341"></a></span>
<span id="cb70-342"><a href="#cb70-342"></a><span class="ss">1. </span>Start R. If not yet done, install the <span class="in">`gdalcubes`</span> package from CRAN, and load it.</span>
<span id="cb70-343"><a href="#cb70-343"></a></span>
<span id="cb70-344"><a href="#cb70-344"></a><span class="ss">2. </span>If not yet done, download the sample dataset from https://hs-bochum.sciebo.de/s/8XcKAmPfPGp2CYh/download and unzip.</span>
<span id="cb70-345"><a href="#cb70-345"></a></span>
<span id="cb70-346"><a href="#cb70-346"></a><span class="ss">3. </span>Create an image collection from all GeoTIFF files in the unzipped directory.</span>
<span id="cb70-347"><a href="#cb70-347"></a></span>
<span id="cb70-348"><a href="#cb70-348"></a><span class="ss">4. </span>Create a *yearly* data cube from the image collection, covering the full spatiotemporal extent at 1 km resolution, using a *Brazil Mercator* projection (EPSG:5641).</span>
<span id="cb70-349"><a href="#cb70-349"></a></span>
<span id="cb70-350"><a href="#cb70-350"></a><span class="ss">5. </span>Select the near infrared band (<span class="in">`"B05"`</span>) and plot the cube.</span>
<span id="cb70-351"><a href="#cb70-351"></a></span>
<span id="cb70-352"><a href="#cb70-352"></a><span class="ss">6. </span>Create a false-color image for the year 2017, using the red (<span class="in">`"B04"`</span>), swir2 (<span class="in">`"B07"`</span>), and blue (<span class="in">`"B02"`</span>) bands as red, green, and blue channels.  You can select the year 2017 by creating a new data cube view (derived from the previous view, and setting both <span class="in">`t0 = "2017"`</span>, and <span class="in">`t1 = "2017"`</span>).</span>
<span id="cb70-353"><a href="#cb70-353"></a></span>
<span id="cb70-354"><a href="#cb70-354"></a></span>
<span id="cb70-355"><a href="#cb70-355"></a></span>
<span id="cb70-356"><a href="#cb70-356"></a></span>
<span id="cb70-357"><a href="#cb70-357"></a></span>
<span id="cb70-358"><a href="#cb70-358"></a></span>
<span id="cb70-359"><a href="#cb70-359"></a></span>
<span id="cb70-360"><a href="#cb70-360"></a>----------------------------------</span>
<span id="cb70-361"><a href="#cb70-361"></a></span>
<span id="cb70-362"><a href="#cb70-362"></a></span>
<span id="cb70-363"><a href="#cb70-363"></a></span>
<span id="cb70-364"><a href="#cb70-364"></a></span>
<span id="cb70-365"><a href="#cb70-365"></a><span class="fu"># Part II: On-the-fly Processing of Data Cubes</span></span>
<span id="cb70-366"><a href="#cb70-366"></a> </span>
<span id="cb70-367"><a href="#cb70-367"></a></span>
<span id="cb70-368"><a href="#cb70-368"></a></span>
<span id="cb70-369"><a href="#cb70-369"></a></span>
<span id="cb70-370"><a href="#cb70-370"></a>The gdalcubes package comes with some built-in operations on data cubes. The following operations produce a derived data cube from one or more input data cubes.</span>
<span id="cb70-371"><a href="#cb70-371"></a></span>
<span id="cb70-372"><a href="#cb70-372"></a>| Operation           | Description                                                                        | </span>
<span id="cb70-373"><a href="#cb70-373"></a>|:--------------------|:-----------------------------------------------------------------------------------|     </span>
<span id="cb70-374"><a href="#cb70-374"></a>|<span class="in">`select_bands`</span>       | Select a subset of a data cube's bands.  |</span>
<span id="cb70-375"><a href="#cb70-375"></a>|<span class="in">`reduce_time`</span>        | Apply a reducer function to all pixel time series. |</span>
<span id="cb70-376"><a href="#cb70-376"></a>|<span class="in">`reduce_space`</span>       | Apply a reducer function to all spatial slices of a data cube.  |</span>
<span id="cb70-377"><a href="#cb70-377"></a>|<span class="in">`apply_pixel`</span>        | Apply an arithmetic expression to all data cube pixels.    |</span>
<span id="cb70-378"><a href="#cb70-378"></a>|<span class="in">`filter_pixel`</span>       | Filter pixels by a logical expressions on band values. |</span>
<span id="cb70-379"><a href="#cb70-379"></a>|<span class="in">`window_time`</span>        | Apply a moving window aggregate or convolution kernel to all pixel time series. |</span>
<span id="cb70-380"><a href="#cb70-380"></a>|<span class="in">`fill_time`</span>          | Fill missing values of a data cube by simple time series interpolation. |</span>
<span id="cb70-381"><a href="#cb70-381"></a>|<span class="in">`join_bands`</span>         | Combine bands of two identically shaped data cubes. |</span>
<span id="cb70-382"><a href="#cb70-382"></a>|<span class="in">`filter_geom`</span>        | Filter pixels by a a spatial polygon. |</span>
<span id="cb70-383"><a href="#cb70-383"></a>|<span class="in">`crop`</span>               | Extract a rectangular spatial / temporal / spatiotemporal window. |</span>
<span id="cb70-384"><a href="#cb70-384"></a>|<span class="in">`select_time`</span>        | Select irregular time slices of a data cube. |</span>
<span id="cb70-385"><a href="#cb70-385"></a>|<span class="in">`slice_time`</span>         | Select a single time slice of a data cube. |</span>
<span id="cb70-386"><a href="#cb70-386"></a>|<span class="in">`slice_space`</span>        | select a single time series of a data cube. |</span>
<span id="cb70-387"><a href="#cb70-387"></a>|<span class="in">`aggregate_time`</span>     | Aggregate and/or regularize time series. |</span>
<span id="cb70-388"><a href="#cb70-388"></a>|<span class="in">`aggregate_space`</span>    | Reduce spatial resolution of a cube by applying a spatial aggregation function. |</span>
<span id="cb70-389"><a href="#cb70-389"></a></span>
<span id="cb70-390"><a href="#cb70-390"></a></span>
<span id="cb70-391"><a href="#cb70-391"></a>These operations can be chained (e.g., using the pipe operator <span class="in">`|&gt;`</span>, which passes a left-hand-side R expression as the first argument to the function on the right-hand-side (e.g. <span class="in">`rnorm(100) |&gt; mean`</span>). </span>
<span id="cb70-392"><a href="#cb70-392"></a></span>
<span id="cb70-393"><a href="#cb70-393"></a>The implementation of these operations in gdalcubes works chunk-wise, i.e. reads only the chunk of the input data cube that is currently needed. This makes sure that only small parts are needed in main memory. </span>
<span id="cb70-394"><a href="#cb70-394"></a></span>
<span id="cb70-395"><a href="#cb70-395"></a></span>
<span id="cb70-396"><a href="#cb70-396"></a></span>
<span id="cb70-397"><a href="#cb70-397"></a></span>
<span id="cb70-398"><a href="#cb70-398"></a><span class="fu">## Arithmetic Expressions on Data Cube Bands</span></span>
<span id="cb70-399"><a href="#cb70-399"></a></span>
<span id="cb70-400"><a href="#cb70-400"></a>The <span class="in">`apply_pixel()`</span> function can be used to apply per-pixel arithmetic expressions on band values of a data cube. Examples include the calculation of vegetation indexes. The function takes a data cube, a string vector of arithmetic expressions, and a vector of result band names as arguments. Below, we derive the normalized difference vegetation index (NDVI) from the red and near infrared (NIR) channel.</span>
<span id="cb70-401"><a href="#cb70-401"></a>We can apply multiple expressions at the same time by providing a vector of expressions (and names).</span>
<span id="cb70-402"><a href="#cb70-402"></a></span>
<span id="cb70-403"><a href="#cb70-403"></a></span>
<span id="cb70-404"><a href="#cb70-404"></a><span class="in">```{r L8ndvi}</span></span>
<span id="cb70-405"><a href="#cb70-405"></a>L8.ndvi <span class="ot">=</span> <span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m, <span class="at">mask=</span>L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb70-406"><a href="#cb70-406"></a>  <span class="fu">select_bands</span>(<span class="fu">c</span>(<span class="st">"B04"</span>,<span class="st">"B05"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb70-407"><a href="#cb70-407"></a>  <span class="fu">apply_pixel</span>(<span class="st">"(B05-B04)/(B05+B04)"</span> , <span class="at">names =</span> <span class="st">"NDVI"</span>, <span class="at">keep_bands=</span><span class="cn">FALSE</span>)</span>
<span id="cb70-408"><a href="#cb70-408"></a></span>
<span id="cb70-409"><a href="#cb70-409"></a>L8.ndvi</span>
<span id="cb70-410"><a href="#cb70-410"></a><span class="fu">plot</span>(L8.ndvi, <span class="at">col=</span>viridis<span class="sc">::</span>viridis, <span class="at">zlim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.3</span>,<span class="dv">1</span>), <span class="at">key.pos =</span> <span class="dv">1</span>)</span>
<span id="cb70-411"><a href="#cb70-411"></a><span class="in">```</span></span>
<span id="cb70-412"><a href="#cb70-412"></a></span>
<span id="cb70-413"><a href="#cb70-413"></a>Creating a chain of data cube operations still returns proxy objects, knowing the size and shape of the output data cube, before calling plot will start computations. In the example, we do not need the original bands after computing the NDVI and set <span class="in">`keep_bands = FALSE`</span> (this is the default). </span>
<span id="cb70-414"><a href="#cb70-414"></a></span>
<span id="cb70-415"><a href="#cb70-415"></a>Similar to <span class="in">`apply_pixel()`</span> we can filter pixels by arithmetic expressions with <span class="in">`filter_pixel()`</span>.  Values of all bands for pixels not fulfilling a logical expression will be set to NA.</span>
<span id="cb70-416"><a href="#cb70-416"></a></span>
<span id="cb70-417"><a href="#cb70-417"></a><span class="in">```{r L8nbr}</span></span>
<span id="cb70-418"><a href="#cb70-418"></a><span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m, <span class="at">mask=</span>L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb70-419"><a href="#cb70-419"></a>  <span class="fu">select_bands</span>(<span class="fu">c</span>(<span class="st">"B05"</span>,<span class="st">"B07"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb70-420"><a href="#cb70-420"></a>  <span class="fu">apply_pixel</span>(<span class="st">"(B05-B07)/(B05+B07)"</span> , <span class="at">names =</span> <span class="st">"NBR"</span>) <span class="sc">|&gt;</span></span>
<span id="cb70-421"><a href="#cb70-421"></a>  <span class="fu">filter_pixel</span>(<span class="st">"NBR &lt; 0.5"</span>) <span class="sc">|&gt;</span></span>
<span id="cb70-422"><a href="#cb70-422"></a>  <span class="fu">plot</span>(<span class="at">col=</span>viridis<span class="sc">::</span>viridis, <span class="at">zlim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>,<span class="fl">0.5</span>), <span class="at">key.pos =</span> <span class="dv">1</span>)</span>
<span id="cb70-423"><a href="#cb70-423"></a><span class="in">```</span></span>
<span id="cb70-424"><a href="#cb70-424"></a></span>
<span id="cb70-425"><a href="#cb70-425"></a></span>
<span id="cb70-426"><a href="#cb70-426"></a><span class="fu">## Reduction Over Time and Space</span></span>
<span id="cb70-427"><a href="#cb70-427"></a></span>
<span id="cb70-428"><a href="#cb70-428"></a>Data cubes can be reduced over the space and time dimensions. The <span class="in">`reduce_time()`</span> function applies one or more reducer functions over pixel time series, producing a single (multiband) result image, whereas <span class="in">`reduce_space()`</span> reduces time slices in the cube to single values (per band), resulting in a single (multiband) time series.</span>
<span id="cb70-429"><a href="#cb70-429"></a></span>
<span id="cb70-430"><a href="#cb70-430"></a>The example below derives median NDVI values over all pixel time series.</span>
<span id="cb70-431"><a href="#cb70-431"></a></span>
<span id="cb70-432"><a href="#cb70-432"></a><span class="in">```{r L8reducetime1}</span></span>
<span id="cb70-433"><a href="#cb70-433"></a><span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m, <span class="at">mask=</span>L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb70-434"><a href="#cb70-434"></a>  <span class="fu">select_bands</span>(<span class="fu">c</span>(<span class="st">"B04"</span>,<span class="st">"B05"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb70-435"><a href="#cb70-435"></a>  <span class="fu">apply_pixel</span>(<span class="st">"(B05-B04)/(B05+B04)"</span>, <span class="at">names =</span> <span class="st">"NDVI"</span>, <span class="at">keep_bands=</span><span class="cn">FALSE</span>) <span class="sc">|&gt;</span></span>
<span id="cb70-436"><a href="#cb70-436"></a>  <span class="fu">reduce_time</span>(<span class="st">"median(NDVI)"</span>) <span class="sc">|&gt;</span></span>
<span id="cb70-437"><a href="#cb70-437"></a>  <span class="fu">plot</span>(<span class="at">col=</span>viridis<span class="sc">::</span>viridis, <span class="at">nbreaks=</span><span class="dv">100</span>, <span class="at">zlim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.3</span>,<span class="dv">1</span>), <span class="at">key.pos =</span> <span class="dv">1</span>)</span>
<span id="cb70-438"><a href="#cb70-438"></a><span class="in">```</span></span>
<span id="cb70-439"><a href="#cb70-439"></a></span>
<span id="cb70-440"><a href="#cb70-440"></a>Possible reducers include <span class="in">`"min"`</span>, <span class="in">`"mean"`</span>, <span class="in">`"median"`</span>, <span class="in">`"max"`</span>, <span class="in">`"count"`</span> (count non-missing values), <span class="in">`"sum"`</span>, <span class="in">`"var"`</span> (variance), and <span class="in">`"sd"`</span> (standard deviation). Reducer expressions are always given as a string starting with the reducer name followed by the band name in parentheses. Notice that it is not possible to apply more complex arithmetic expressions here.  It is however possible to mix reducers and bands:</span>
<span id="cb70-441"><a href="#cb70-441"></a></span>
<span id="cb70-442"><a href="#cb70-442"></a><span class="in">```{r L8reducetime2}</span></span>
<span id="cb70-443"><a href="#cb70-443"></a><span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m, <span class="at">mask=</span>L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb70-444"><a href="#cb70-444"></a>  <span class="fu">select_bands</span>(<span class="fu">c</span>(<span class="st">"B04"</span>,<span class="st">"B05"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb70-445"><a href="#cb70-445"></a>  <span class="fu">apply_pixel</span>(<span class="st">"(B05-B04)/(B05+B04)"</span>, <span class="at">names =</span> <span class="st">"NDVI"</span>, <span class="at">keep_bands=</span><span class="cn">TRUE</span>) <span class="sc">|&gt;</span></span>
<span id="cb70-446"><a href="#cb70-446"></a>  <span class="fu">reduce_time</span>(<span class="st">"median(NDVI)"</span>, <span class="st">"mean(NDVI)"</span>,<span class="st">"max(B05)"</span>)</span>
<span id="cb70-447"><a href="#cb70-447"></a><span class="in">```</span></span>
<span id="cb70-448"><a href="#cb70-448"></a></span>
<span id="cb70-449"><a href="#cb70-449"></a>Results of <span class="in">`reduce_space()`</span> are plotted as simple time series.</span>
<span id="cb70-450"><a href="#cb70-450"></a></span>
<span id="cb70-451"><a href="#cb70-451"></a><span class="in">```{r L8space1}</span></span>
<span id="cb70-452"><a href="#cb70-452"></a><span class="fu">raster_cube</span>(L8.col, v.subarea<span class="fl">.60</span>m,  <span class="at">mask=</span>L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb70-453"><a href="#cb70-453"></a>  <span class="fu">select_bands</span>(<span class="fu">c</span>(<span class="st">"B04"</span>,<span class="st">"B05"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb70-454"><a href="#cb70-454"></a>  <span class="fu">apply_pixel</span>(<span class="st">"(B05-B04)/(B05+B04)"</span>, <span class="at">names =</span> <span class="st">"NDVI"</span>) <span class="sc">|&gt;</span></span>
<span id="cb70-455"><a href="#cb70-455"></a>  <span class="fu">reduce_space</span>(<span class="st">"median(NDVI)"</span>, <span class="st">"sd(NDVI)"</span>) <span class="sc">|&gt;</span></span>
<span id="cb70-456"><a href="#cb70-456"></a>  <span class="fu">plot</span>()</span>
<span id="cb70-457"><a href="#cb70-457"></a><span class="in">```</span></span>
<span id="cb70-458"><a href="#cb70-458"></a></span>
<span id="cb70-459"><a href="#cb70-459"></a>The <span class="in">`"count"`</span> reducer is often very useful to get an initial understanding of an image collection.</span>
<span id="cb70-460"><a href="#cb70-460"></a></span>
<span id="cb70-461"><a href="#cb70-461"></a><span class="in">```{r L8reducetime_count}</span></span>
<span id="cb70-462"><a href="#cb70-462"></a><span class="fu">raster_cube</span>(L8.col, <span class="fu">cube_view</span>(<span class="at">view=</span>v.overview<span class="fl">.500</span>m, <span class="at">dt=</span><span class="st">"P1D"</span>), <span class="at">mask=</span>L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb70-463"><a href="#cb70-463"></a>  <span class="fu">select_bands</span>(<span class="fu">c</span>(<span class="st">"B01"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb70-464"><a href="#cb70-464"></a>  <span class="fu">reduce_time</span>(<span class="st">"count(B01)"</span>) <span class="sc">|&gt;</span></span>
<span id="cb70-465"><a href="#cb70-465"></a>  <span class="fu">plot</span>(<span class="at">key.pos=</span><span class="dv">1</span>)</span>
<span id="cb70-466"><a href="#cb70-466"></a><span class="in">```</span></span>
<span id="cb70-467"><a href="#cb70-467"></a></span>
<span id="cb70-468"><a href="#cb70-468"></a><span class="in">```{r L8reducespace_count}</span></span>
<span id="cb70-469"><a href="#cb70-469"></a><span class="fu">raster_cube</span>(L8.col, <span class="fu">cube_view</span>(<span class="at">view=</span>v.overview<span class="fl">.500</span>m, <span class="at">dt=</span><span class="st">"P1M"</span>), <span class="at">mask=</span>L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb70-470"><a href="#cb70-470"></a>  <span class="fu">select_bands</span>(<span class="st">"B01"</span>) <span class="sc">|&gt;</span></span>
<span id="cb70-471"><a href="#cb70-471"></a>  <span class="fu">reduce_space</span>(<span class="st">"count(B01)"</span>) <span class="sc">|&gt;</span></span>
<span id="cb70-472"><a href="#cb70-472"></a>  <span class="fu">plot</span>()</span>
<span id="cb70-473"><a href="#cb70-473"></a><span class="in">```</span></span>
<span id="cb70-474"><a href="#cb70-474"></a></span>
<span id="cb70-475"><a href="#cb70-475"></a>We can see that there are almost no observations during the months from October to May, because the download was limited to images with low cloud percentages.</span>
<span id="cb70-476"><a href="#cb70-476"></a></span>
<span id="cb70-477"><a href="#cb70-477"></a></span>
<span id="cb70-478"><a href="#cb70-478"></a></span>
<span id="cb70-479"><a href="#cb70-479"></a><span class="fu">## Time-series methods</span></span>
<span id="cb70-480"><a href="#cb70-480"></a></span>
<span id="cb70-481"><a href="#cb70-481"></a>There are two more built-in functions that operate on individual pixel time series. </span>
<span id="cb70-482"><a href="#cb70-482"></a></span>
<span id="cb70-483"><a href="#cb70-483"></a>The <span class="in">`fill_time()`</span> function interpolates missing values by preceding or succeeding values (using simple linear or nearest neighbor interpolation, or carrying observations forwards or backwards), The <span class="in">`window_time()`</span> function can either apply a moving window kernel, or apply a reducer function over moving windows. </span>
<span id="cb70-484"><a href="#cb70-484"></a></span>
<span id="cb70-485"><a href="#cb70-485"></a>In the example below, we sum NDVI changes between subsequent time slices in the data cube, and visualize the result using a diverging color scale from the <span class="in">`RColorBrewer`</span> package.</span>
<span id="cb70-486"><a href="#cb70-486"></a></span>
<span id="cb70-487"><a href="#cb70-487"></a><span class="in">```{r L8timeseries}</span></span>
<span id="cb70-488"><a href="#cb70-488"></a><span class="fu">raster_cube</span>(L8.col, <span class="fu">cube_view</span>(<span class="at">view =</span> v.subarea<span class="fl">.60</span>m, <span class="at">extent=</span><span class="fu">list</span>(<span class="at">t0=</span><span class="st">"2014-01"</span>,<span class="at">t1=</span><span class="st">"2018-12"</span>)), <span class="at">mask=</span>L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb70-489"><a href="#cb70-489"></a>  <span class="fu">select_bands</span>(<span class="fu">c</span>(<span class="st">"B04"</span>,<span class="st">"B05"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb70-490"><a href="#cb70-490"></a>  <span class="fu">apply_pixel</span>(<span class="st">"(B05-B04)/(B05+B04)"</span>, <span class="at">names =</span> <span class="st">"NDVI"</span>) <span class="sc">|&gt;</span></span>
<span id="cb70-491"><a href="#cb70-491"></a>  <span class="fu">fill_time</span>(<span class="at">method =</span> <span class="st">"locf"</span>) <span class="sc">|&gt;</span></span>
<span id="cb70-492"><a href="#cb70-492"></a>  <span class="fu">window_time</span>(<span class="at">kernel =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>,<span class="dv">1</span>), <span class="at">window=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">0</span>)) <span class="sc">|&gt;</span></span>
<span id="cb70-493"><a href="#cb70-493"></a>  <span class="fu">reduce_time</span>(<span class="st">"sum(NDVI)"</span>) <span class="sc">|&gt;</span></span>
<span id="cb70-494"><a href="#cb70-494"></a>  <span class="fu">plot</span>(<span class="at">zlim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.4</span>,<span class="fl">0.4</span>),<span class="at">nbreaks =</span> <span class="dv">12</span>, <span class="at">col=</span>RColorBrewer<span class="sc">::</span><span class="fu">brewer.pal</span>(<span class="dv">11</span>, <span class="st">"RdYlBu"</span>), <span class="at">key.pos=</span><span class="dv">1</span>)</span>
<span id="cb70-495"><a href="#cb70-495"></a><span class="in">```</span></span>
<span id="cb70-496"><a href="#cb70-496"></a></span>
<span id="cb70-497"><a href="#cb70-497"></a></span>
<span id="cb70-498"><a href="#cb70-498"></a></span>
<span id="cb70-499"><a href="#cb70-499"></a><span class="fu">## User-defined Functions</span></span>
<span id="cb70-500"><a href="#cb70-500"></a></span>
<span id="cb70-501"><a href="#cb70-501"></a></span>
<span id="cb70-502"><a href="#cb70-502"></a>So far, we have provided expressions and reducers as characters / strings. The reasons was that these methods automatically translate to C++, i.e. are evaluated in the C++ code. In the current version, <span class="in">`reduce_time()`</span>, and <span class="in">`apply_pixel()`</span> may also receive R functions as argument. This opens up quite a bunch of things we can do, e.g. using functions from our favorite R packages to process pixel time series. In the example below, we simply fit a line to individual NDVI pixel time series and return its slope (trend).</span>
<span id="cb70-503"><a href="#cb70-503"></a></span>
<span id="cb70-504"><a href="#cb70-504"></a></span>
<span id="cb70-505"><a href="#cb70-505"></a><span class="in">```{r L8udf}</span></span>
<span id="cb70-506"><a href="#cb70-506"></a><span class="fu">raster_cube</span>(L8.col, <span class="fu">cube_view</span>(<span class="at">view =</span> v.subarea<span class="fl">.60</span>m, <span class="at">dx=</span><span class="dv">200</span>), <span class="at">mask =</span> L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb70-507"><a href="#cb70-507"></a>  <span class="fu">select_bands</span>(<span class="fu">c</span>(<span class="st">"B04"</span>,<span class="st">"B05"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb70-508"><a href="#cb70-508"></a>  <span class="fu">apply_pixel</span>(<span class="st">"(B05-B04)/(B05+B04)"</span>, <span class="at">names =</span> <span class="st">"NDVI"</span>) <span class="sc">|&gt;</span></span>
<span id="cb70-509"><a href="#cb70-509"></a>  <span class="fu">reduce_time</span>(<span class="at">names=</span><span class="fu">c</span>(<span class="st">"ndvi_trend"</span>), <span class="at">FUN=</span><span class="cf">function</span>(x) {</span>
<span id="cb70-510"><a href="#cb70-510"></a>    z <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">t=</span><span class="dv">1</span><span class="sc">:</span><span class="fu">ncol</span>(x), <span class="at">ndvi=</span>x[<span class="st">"NDVI"</span>,])</span>
<span id="cb70-511"><a href="#cb70-511"></a>    result <span class="ot">=</span> <span class="cn">NA</span></span>
<span id="cb70-512"><a href="#cb70-512"></a>    <span class="cf">if</span> (<span class="fu">sum</span>(<span class="sc">!</span><span class="fu">is.na</span>(z<span class="sc">$</span>ndvi)) <span class="sc">&gt;</span> <span class="dv">3</span>) {</span>
<span id="cb70-513"><a href="#cb70-513"></a>      result <span class="ot">=</span> <span class="fu">coef</span>(<span class="fu">lm</span>(ndvi <span class="sc">~</span> t, z, <span class="at">na.action =</span> na.exclude))[<span class="dv">2</span>]</span>
<span id="cb70-514"><a href="#cb70-514"></a>    }</span>
<span id="cb70-515"><a href="#cb70-515"></a>    <span class="fu">return</span>(result) </span>
<span id="cb70-516"><a href="#cb70-516"></a>  }) <span class="sc">|&gt;</span></span>
<span id="cb70-517"><a href="#cb70-517"></a>  <span class="fu">plot</span>(<span class="at">key.pos=</span><span class="dv">1</span>, <span class="at">col=</span>viridis<span class="sc">::</span>viridis)</span>
<span id="cb70-518"><a href="#cb70-518"></a><span class="in">```</span></span>
<span id="cb70-519"><a href="#cb70-519"></a></span>
<span id="cb70-520"><a href="#cb70-520"></a>There is no limit in what we can do in the provided R function, but we must take care of a few things:</span>
<span id="cb70-521"><a href="#cb70-521"></a></span>
<span id="cb70-522"><a href="#cb70-522"></a><span class="ss">1. </span>The reducer function is executed in a new R process without access to the current workspace. It is not possible to access variables defined outside of the function and packages must be loaded **within** the function.</span>
<span id="cb70-523"><a href="#cb70-523"></a></span>
<span id="cb70-524"><a href="#cb70-524"></a><span class="ss">2. </span>The reducer function **must** always return a vector with the same length (for all time series).</span>
<span id="cb70-525"><a href="#cb70-525"></a></span>
<span id="cb70-526"><a href="#cb70-526"></a><span class="ss">3. </span>It is a good idea to think about <span class="in">`NA`</span> values, i.e. you should check whether the complete time series is <span class="in">`NA`</span>, and that missing values do not produce errors.</span>
<span id="cb70-527"><a href="#cb70-527"></a></span>
<span id="cb70-528"><a href="#cb70-528"></a></span>
<span id="cb70-529"><a href="#cb70-529"></a></span>
<span id="cb70-530"><a href="#cb70-530"></a></span>
<span id="cb70-531"><a href="#cb70-531"></a></span>
<span id="cb70-532"><a href="#cb70-532"></a><span class="fu">## For Developers: Process Graphs</span></span>
<span id="cb70-533"><a href="#cb70-533"></a></span>
<span id="cb70-534"><a href="#cb70-534"></a>Chaining processes works lazliy; internally gdalcubes creates a *process graph* of operations that can be serialized as JSON:</span>
<span id="cb70-535"><a href="#cb70-535"></a></span>
<span id="cb70-536"><a href="#cb70-536"></a><span class="in">```{r json}</span></span>
<span id="cb70-537"><a href="#cb70-537"></a><span class="fu">raster_cube</span>(L8.col, <span class="fu">cube_view</span>(<span class="at">view =</span> v.subarea<span class="fl">.60</span>m, <span class="at">extent=</span><span class="fu">list</span>(<span class="at">t0=</span><span class="st">"2014-01"</span>,<span class="at">t1=</span><span class="st">"2018-12"</span>)), <span class="at">mask=</span>L8.clear_mask) <span class="sc">|&gt;</span></span>
<span id="cb70-538"><a href="#cb70-538"></a>  <span class="fu">select_bands</span>(<span class="fu">c</span>(<span class="st">"B04"</span>,<span class="st">"B05"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb70-539"><a href="#cb70-539"></a>  <span class="fu">apply_pixel</span>(<span class="st">"(B05-B04)/(B05+B04)"</span>, <span class="at">names =</span> <span class="st">"NDVI"</span>) <span class="sc">|&gt;</span></span>
<span id="cb70-540"><a href="#cb70-540"></a>  <span class="fu">fill_time</span>(<span class="at">method =</span> <span class="st">"locf"</span>) <span class="sc">|&gt;</span></span>
<span id="cb70-541"><a href="#cb70-541"></a>  <span class="fu">window_time</span>(<span class="at">kernel =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>,<span class="dv">1</span>), <span class="at">window=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">0</span>)) <span class="sc">|&gt;</span></span>
<span id="cb70-542"><a href="#cb70-542"></a>  <span class="fu">reduce_time</span>(<span class="st">"sum(NDVI)"</span>) <span class="sc">|&gt;</span></span>
<span id="cb70-543"><a href="#cb70-543"></a>  <span class="fu">as_json</span>() <span class="sc">|&gt;</span></span>
<span id="cb70-544"><a href="#cb70-544"></a>  <span class="fu">cat</span>()</span>
<span id="cb70-545"><a href="#cb70-545"></a><span class="in">```</span></span>
<span id="cb70-546"><a href="#cb70-546"></a></span>
<span id="cb70-547"><a href="#cb70-547"></a>This is allows to easily recreate chains of operations, and helps e.g. to cache results. </span>
<span id="cb70-548"><a href="#cb70-548"></a></span>
<span id="cb70-549"><a href="#cb70-549"></a></span>
<span id="cb70-550"><a href="#cb70-550"></a></span>
<span id="cb70-551"><a href="#cb70-551"></a>--------------------------------------------------</span>
<span id="cb70-552"><a href="#cb70-552"></a></span>
<span id="cb70-553"><a href="#cb70-553"></a></span>
<span id="cb70-554"><a href="#cb70-554"></a><span class="fu"># Summary, Limitations, and Future Work </span></span>
<span id="cb70-555"><a href="#cb70-555"></a></span>
<span id="cb70-556"><a href="#cb70-556"></a>On-demand raster data cubes as implemented in gdalcubes make it easier to</span>
<span id="cb70-557"><a href="#cb70-557"></a></span>
<span id="cb70-558"><a href="#cb70-558"></a><span class="ss">- </span>analyze time series of large satellite image collections</span>
<span id="cb70-559"><a href="#cb70-559"></a><span class="ss">- </span>experiment on lower resolution first</span>
<span id="cb70-560"><a href="#cb70-560"></a><span class="ss">- </span>scale computations </span>
<span id="cb70-561"><a href="#cb70-561"></a><span class="ss">- </span>combine data from different sensors / satellites</span>
<span id="cb70-562"><a href="#cb70-562"></a></span>
<span id="cb70-563"><a href="#cb70-563"></a>Though gdalcubes works with quite a few datasets directly, others require additional preprocessing. These include radar datasets such as Sentinel-1, or datasets on curvilinear grids, such as Sentinel-5P. </span>
<span id="cb70-564"><a href="#cb70-564"></a></span>
<span id="cb70-565"><a href="#cb70-565"></a>gdalcubes can work directly in cloud computing environments. It uses GDAL to read images and hence can use GDAL's virtual file systems to access data on object storage (e.g. AWS S3 buckets). Processing cubes in distributed (cloud) computing environments is a bit more difficult and is current work in progress. </span>
<span id="cb70-566"><a href="#cb70-566"></a></span>
<span id="cb70-567"><a href="#cb70-567"></a>gdalcubes is a pretty young tool, there are many ideas still to be implemented (e.g. Python interface, user-defined function support for further operations, interfacing image processing libraries such as Orfeo Toolbox, using gdalcubes as a fully open source <span class="co">[</span><span class="ot">OpenEO</span><span class="co">](https://openeo.org/)</span> backend, ...).  </span>
<span id="cb70-568"><a href="#cb70-568"></a></span>
<span id="cb70-569"><a href="#cb70-569"></a>If you have further ideas, questions, or would like to contribute in any other way, please just ask me, or create issues at <span class="co">[</span><span class="ot">GitHub</span><span class="co">](https://github.com/appelmar/gdalcubes_R)</span>.</span>
<span id="cb70-570"><a href="#cb70-570"></a></span>
<span id="cb70-571"><a href="#cb70-571"></a></span>
<span id="cb70-572"><a href="#cb70-572"></a></span>
<span id="cb70-573"><a href="#cb70-573"></a></span>
<span id="cb70-574"><a href="#cb70-574"></a>-------------------------------------------------------------------------------</span>
<span id="cb70-575"><a href="#cb70-575"></a></span>
<span id="cb70-576"><a href="#cb70-576"></a><span class="fu"># Exercises (ii)</span></span>
<span id="cb70-577"><a href="#cb70-577"></a></span>
<span id="cb70-578"><a href="#cb70-578"></a></span>
<span id="cb70-579"><a href="#cb70-579"></a><span class="ss">1. </span>Use the downsampled Landsat dataset from the first exercises and create a data cube for a spatial subarea (use the data cube view and mask below).</span>
<span id="cb70-580"><a href="#cb70-580"></a></span>
<span id="cb70-581"><a href="#cb70-581"></a><span class="in">```</span></span>
<span id="cb70-582"><a href="#cb70-582"></a><span class="in">v.subarea = cube_view(extent=list(left=-6320000, right=-6220000, bottom=-600000, top=-500000, </span></span>
<span id="cb70-583"><a href="#cb70-583"></a><span class="in">        t0="2014-01-01", t1="2018-12-31"), dt="P1M", dx=100, dy=100</span></span>
<span id="cb70-584"><a href="#cb70-584"></a><span class="in">        srs="EPSG:3857", aggregation = "median", resampling = "bilinear")</span></span>
<span id="cb70-585"><a href="#cb70-585"></a><span class="in">                      </span></span>
<span id="cb70-586"><a href="#cb70-586"></a><span class="in">L8.clear_mask = image_mask("PIXEL_QA", values=</span></span>
<span id="cb70-587"><a href="#cb70-587"></a><span class="in">        c(322, 386, 834, 898, 1346, 324, 388, 836, 900, 1348), </span></span>
<span id="cb70-588"><a href="#cb70-588"></a><span class="in">        invert = TRUE)</span></span>
<span id="cb70-589"><a href="#cb70-589"></a><span class="in">```</span></span>
<span id="cb70-590"><a href="#cb70-590"></a></span>
<span id="cb70-591"><a href="#cb70-591"></a><span class="ss">2. </span>Calculate the normalized difference moisture index (NDMI) using the formula "(B05-B06)/(B05+B06)". This index is used to assess vegetation water content. </span>
<span id="cb70-592"><a href="#cb70-592"></a></span>
<span id="cb70-593"><a href="#cb70-593"></a><span class="ss">3. </span>Compute minimum, maximum, median, and mean NDMI values over time and plot the result.</span>
<span id="cb70-594"><a href="#cb70-594"></a></span>
<span id="cb70-595"><a href="#cb70-595"></a><span class="ss">4. </span>Calculate the NDVI as in the tutorial, and apply a user defined reducer function to create a "greenest pixel" composit image, by finding the date/time of the maximum NDVI, and returning the corresponding RGB values. </span>
<span id="cb70-596"><a href="#cb70-596"></a></span>
<span id="cb70-597"><a href="#cb70-597"></a></span>
<span id="cb70-598"><a href="#cb70-598"></a></span>
<span id="cb70-599"><a href="#cb70-599"></a></span>
<span id="cb70-600"><a href="#cb70-600"></a><span class="fu"># References</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer"><div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
<li class="nav-item">
 © 2024 Marius Appel
  </li>  
</ul>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>


</body></html>